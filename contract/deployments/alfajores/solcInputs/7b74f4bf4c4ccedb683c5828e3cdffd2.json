{
  "language": "Solidity",
  "sources": {
    "@thirdweb-dev/contracts/external-deps/openzeppelin/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/apis/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IERC20 } from './IERC20.sol';\r\n\r\ninterface Common {\r\n    event PoolCreated(Pool);\r\n    event NewContributorAdded(Pool);\r\n    event GetFinanced(Pool);\r\n    event Payback(Pool);\r\n    event Liquidated(Pool);\r\n    event Cancellation(uint unit);\r\n    event PoolEdited(Pool);\r\n\r\n    enum Stage {\r\n        JOIN, \r\n        GET, \r\n        PAYBACK, \r\n        CANCELED,\r\n        ENDED\r\n    }\r\n\r\n    enum Status { AVAILABLE, TAKEN }\r\n\r\n    enum Branch { CURRENT, RECORD }\r\n\r\n    enum Router { PERMISSIONLESS, PERMISSIONED }\r\n\r\n    struct Pool {\r\n        Low low;\r\n        Big big;\r\n        Addresses addrs;\r\n        Router router;\r\n        Stage stage;\r\n        Status status;\r\n    }\r\n\r\n    struct Low {\r\n        uint8 maxQuorum;\r\n        uint8 selector;\r\n        uint24 colCoverage;\r\n        uint32 duration;\r\n        uint8 allGh;\r\n        uint8 userCount;\r\n    }\r\n\r\n    struct Big {\r\n        uint256 unit;\r\n        uint256 currentPool;\r\n        uint96 recordId;\r\n        uint96 unitId;\r\n    }\r\n\r\n    struct Point {\r\n        uint contributor;\r\n        uint creator;\r\n        uint referrals;\r\n    }\r\n\r\n    struct Interest {\r\n        uint fullInterest;\r\n        uint intPerSec;\r\n    }\r\n\r\n    /**\r\n     * @notice Structured types - Address\r\n     * @param asset : Contract address of the asset in use.\r\n     * @param lastPaid: Last contributor who got finance.\r\n     * @param safe : Strategy for each pool or epoch. See Strategy.sol for more details.\r\n     * @param admin : Pool creator.\r\n     * \r\n    */\r\n    struct Addresses {\r\n        IERC20 colAsset;\r\n        address lastPaid;\r\n        address safe;\r\n        address admin;\r\n    }\r\n\r\n    /**\r\n     *  @param isMember : Whether user is a member or not\r\n     *  @param turnStartTime: Time when the contributor's turn start to count.\r\n     *  @param getFinanceTime: Date when loan was disbursed\r\n     *  @param paybackTime: Date which the borrowed fund must be retured\r\n     *  @param loan: Total debts owed by the last fund recipient.\r\n     *  @param colBals: Collateral balances of the last recipient.\r\n     *  @param sentQuota : Whether an user/current msg.sender has received or not.\r\n     *  @param id : Address of the last recipient.\r\n     * @param interestPaid : The amount of interest paid  \r\n    */\r\n    struct Contributor {\r\n        uint32 paybackTime;\r\n        uint32 turnStartTime;\r\n        uint32 getFinanceTime;\r\n        uint loan;\r\n        uint colBals;\r\n        address id;\r\n        bool sentQuota;\r\n    }\r\n\r\n    struct Price {\r\n        uint128 price;\r\n        uint8 decimals;\r\n    }\r\n\r\n    struct Provider {\r\n        uint slot;\r\n        uint amount;\r\n        uint rate;\r\n        uint earnStartDate;\r\n        address account;\r\n        Interest accruals;\r\n    }\r\n\r\n    struct Payback_Safe {\r\n        address user; \r\n        IERC20 baseAsset; \r\n        uint256 debt;\r\n        uint256 attestedInitialBal;\r\n        bool allGF; \r\n        Contributor[] cData;\r\n        bool isSwapped;\r\n        address defaulted;\r\n        uint96 recordId;\r\n        IERC20 collateralAsset;\r\n    }\r\n\r\n    struct Slot {\r\n        uint value;\r\n        bool isMember;\r\n        bool isAdmin;\r\n    }\r\n\r\n    struct ReadDataReturnValue {\r\n        Pool pool;\r\n        Contributor[] cData;\r\n    }\r\n\r\n    struct UpdatePoolData {\r\n        uint unit;\r\n        uint96 unitId;\r\n        uint96 recordId;\r\n        uint8 maxQuorum;\r\n        uint24 colCoverage;\r\n        IERC20 colAsset;\r\n        uint16 durationInHours;\r\n        address creator;\r\n        Router router; \r\n    }\r\n\r\n    struct Analytics {\r\n        uint256 tvlCollateral;\r\n        uint256 tvlBase;\r\n        uint totalPermissioned;\r\n        uint totalPermissionless;\r\n    }\r\n\r\n    struct ViewFactoryData {\r\n        Analytics analytics;\r\n        uint16 makerRate;\r\n        uint currentEpoches;\r\n        uint recordEpoches;\r\n    }\r\n\r\n    struct ContributorReturnValue {\r\n        Contributor profile;\r\n        uint8 slot;\r\n        Common.Provider[] providers;\r\n    }\r\n\r\n}"
    },
    "contracts/apis/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport \"./IERC20Metadata.sol\";\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 is IERC20Metadata{\r\n    error NotCallable();\r\n    error AddressIsZero(address);\r\n    error NoPreviousLockDetected();\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    \r\n    /** \r\n     * @dev Moves `amounts` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event for each transfer.\r\n     * Note: BE AWARE OF THE GAS COST WHEN USING THIS FUNCTION. IT INCREASES \r\n                RELATIVE TO THE ACCOUNTS ARRAY\r\n     */\r\n    function batchTransfer(uint[] memory amounts, address[] memory accounts) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n\r\n    /**@dev Locks specific amount of JFT to the private ledger.\r\n        param: routeTo - Alternative address that funds will be sent to when panic call is made.\r\n        param: amount - Amount to lock.\r\n    */\r\n    function lockToken(address routeTo, uint256 amount) external returns(bool);\r\n\r\n    /**@dev Moves an 'amount' from private ledger to regular balances.\r\n        @param amount - Amount to unlock.\r\n        Note: If the lock duration was set, holder will not be able to unlock until the \r\n            set time has passed else they can withdraw to regular balance anytime.\r\n     */\r\n    function unlockToken(uint amount) external returns(bool);\r\n\r\n    /** @dev Returns seperate balances of @param who\r\n        return value will be in struct format having two values\r\n     */\r\n    function accountBalances(address who) external view returns(Balances memory);\r\n   \r\n    // /**@dev Return JFT's Metadata including the information of `who`\r\n    //  */\r\n    // function getInfo(address who) external view returns(Protected memory);\r\n\r\n    /**\r\n     * @dev PanicUnlock is meant to be invoked only by the Attorney.\r\n     * It should only be called when JFT holder has lost access to their account and they had \r\n     * earlier initiated a lock. The locked token is simply unlocked and sent to an escape address\r\n     * provided at the time the lock was activated.\r\n     * \r\n     * Note: Attorney charges a fee for doing this. \r\n     * @param account : Account that owns this token.\r\n     */\r\n    function panicUnlock(address account, Balances memory _bal) external returns(bool);\r\n\r\n    struct Protected {\r\n        uint256 value; // Total value currently locked\r\n        address escapeTo;\r\n    }\r\n\r\n    struct Balances {\r\n        uint256 spendable;\r\n        Protected locked;\r\n    }\r\n\r\n    struct TokenInfo {\r\n        uint8 decimals;\r\n        uint256 totalSupply;\r\n        string name;\r\n        string symbol;\r\n        address attorney;\r\n        // address rewarder;\r\n    }\r\n}\r\n"
    },
    "contracts/apis/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "contracts/apis/IFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"./Common.sol\";\r\n\r\ninterface IFactory is Common {\r\n  function contributeThroughProvider(Provider[] memory providers, address borrower, uint unit) external returns(bool);\r\n  function getContributorProviders(address target, uint96 recordId) external view returns(Provider[] memory);\r\n}"
    },
    "contracts/apis/IRoleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title IRoleBase \r\n * Interface of the OwnerShip contract\r\n * @author Simplifi (Bobeu)\r\n */\r\ninterface IRoleBase {\r\n    function setRole(\r\n        address[] memory newRoleTos\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function removeRole(\r\n        address target\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function renounceRole() \r\n        external\r\n        returns(bool);\r\n\r\n    function getRoleBearer(\r\n        uint ownerId\r\n    ) \r\n        external \r\n        view \r\n        returns(address);\r\n\r\n    function hasRole(\r\n        address target\r\n    )\r\n        external\r\n        view \r\n        returns(bool);\r\n}"
    },
    "contracts/apis/ISafe.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"./Common.sol\";\r\nimport { IERC20 } from \"./IERC20.sol\";\r\n\r\ninterface ISafe {\r\n  function addUp(address user, uint recordId) external returns(bool);\r\n  function getFinance(\r\n    address user, \r\n    IERC20 baseAsset, \r\n    uint256 loan, \r\n    uint fee, \r\n    uint256 calculatedCol,\r\n    uint recordId\r\n  ) \r\n    external \r\n    returns(bool);\r\n\r\n  function payback(Common.Payback_Safe memory, uint unit) external returns(uint collateral);\r\n  function cancel(address user, IERC20 asset, uint unit, uint recordId) external returns(bool);\r\n  function getData() external view returns(ViewData memory);\r\n\r\n  struct ViewData {\r\n    uint totalClients;\r\n    uint aggregateFee;\r\n  }\r\n\r\n  struct ViewUserData {\r\n    bool access;\r\n    uint collateralBalance;\r\n  }\r\n}"
    },
    "contracts/apis/ISafeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title Interface of the Safe manager\r\n * @author : Simplifinance (Written by Bobeu)\r\n */\r\ninterface ISafeFactory {  \r\n  /**\r\n   * Query safe for user\r\n   * @param unit : Address to get safe for\r\n   * @return A safe if none was found, it returns address(0).\r\n   */\r\n  function getSafe(uint256 unit) external view returns(address);\r\n  // function getSafe(address user) external view returns(address);\r\n\r\n/**\r\n * Clones and return a new safe \r\n * @param unit : Target address for whom to create safe\r\n */\r\n  function pingSafe(uint256 unit) external returns(address safe);\r\n\r\n  /**\r\n   * Safe struct map\r\n   * key: user address { EOA }\r\n   * value: Safe { Contract } \r\n   */\r\n  struct SafeData {\r\n    address key;\r\n    address value;\r\n  }\r\n\r\n}"
    },
    "contracts/libraries/ErrorLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nlibrary ErrorLib {\r\n    error ErrorOccurred(string errorMsg);\r\n\r\n    /**\r\n     * @dev Reverts any operation.\r\n     * @param _error : Error struct\r\n     */\r\n    function _throw(string memory _error) internal pure {\r\n        if(bytes(_error).length > 0){ \r\n            revert ErrorOccurred(_error);\r\n        }\r\n    }\r\n\r\n}"
    },
    "contracts/peripherals/OnlyRoleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IRoleBase } from \"../apis/IRoleBase.sol\";\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\n\r\n/**\r\n * @title MsgSender \r\n * @author Simplifi (Bobeu)\r\n * @notice Non-deployable contract simply returning the calling account.\r\n */\r\nabstract contract MsgSender {\r\n    function _msgSender() internal view virtual returns(address sender) {\r\n        sender = msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract OnlyRoleBase is MsgSender {\r\n    using ErrorLib for *;\r\n\r\n    // Role manager address\r\n    IRoleBase public roleManager;\r\n\r\n    // ============= constructor ============\r\n    constructor(IRoleBase _roleManager)\r\n    {\r\n        _setRoleManager(_roleManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Caller must have owner role before execeution can proceed.\r\n     * The 'errorMessage' argument can be used to return error specific to \r\n     * a context e.g function call. \r\n     */\r\n    modifier onlyRoleBearer {\r\n        _onlyRoleBearer();\r\n        _;\r\n    }\r\n\r\n    // Allow only account with role access\r\n    function _onlyRoleBearer() internal view {\r\n        IRoleBase mgr = roleManager;\r\n        if(address(mgr) == address(0)) 'Manager is zero'._throw();\r\n        if(!_hasRole(_msgSender())) 'Access denied'._throw();\r\n    }\r\n\r\n    function _hasRole(address target) internal view returns(bool result) {\r\n        result = IRoleBase(roleManager).hasRole(target);\r\n    }  \r\n\r\n    /// @dev Set role manager\r\n    function _setRoleManager(IRoleBase newManager) private{\r\n        roleManager = newManager;\r\n    }\r\n\r\n    /**\r\n     * Set Role manager\r\n     * @param newManager : New manager address\r\n     */\r\n    function setRoleManager(\r\n        address newManager\r\n    )\r\n        public\r\n        onlyRoleBearer\r\n        returns(bool)\r\n    {\r\n        _setRoleManager(IRoleBase(newManager));\r\n        return true;\r\n    }\r\n}"
    },
    "contracts/peripherals/Safe.sol": {
      "content": "// SPDX-License-Identifier: MIT \r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { ReentrancyGuard } from \"@thirdweb-dev/contracts/external-deps/openzeppelin/security/ReentrancyGuard.sol\";\r\nimport { IERC20 } from \"../apis/IERC20.sol\";\r\nimport { IFactory } from \"../apis/IFactory.sol\";\r\nimport { ISafe } from \"../apis/ISafe.sol\";\r\nimport { Common } from \"../apis/Common.sol\";\r\nimport { OnlyRoleBase, IRoleBase } from \"../peripherals/OnlyRoleBase.sol\";\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\n\r\ncontract Safe is ISafe, OnlyRoleBase, ReentrancyGuard {\r\n    using ErrorLib for *;\r\n\r\n    // Number of contributors currently operating this safe\r\n    uint private userCount;\r\n\r\n    // Total fee collected\r\n    uint private aggregateFee;\r\n\r\n    // Amount to date paid by contributors\r\n    uint256 public totalAmountIn;\r\n\r\n    // Fee Receiver\r\n    address public immutable feeTo;\r\n\r\n    // Mapping of user to record Id to access\r\n    mapping(address => mapping(uint => bool)) private access;\r\n\r\n    // Mapping of users to recordId to Collateral\r\n    mapping(address => mapping(uint => uint256)) private collateralBalances;\r\n\r\n    // Mapping of contributors to amount paid as debt serviced\r\n    mapping(address contributor => uint) public paybacks;\r\n\r\n    ///@dev Only users with access role are allowed\r\n    modifier hasAccess(address user, uint recordId) {\r\n        if (!access[user][recordId]) 'User does not have access'._throw();\r\n        _;\r\n    }\r\n\r\n    /** ========== Constructor ===============\r\n     * @param _roleManager : RoleBase manager contract\r\n     * @param _feeTo : Fee receiver account\r\n     */\r\n    constructor(IRoleBase _roleManager, address _feeTo) OnlyRoleBase(_roleManager) {\r\n        feeTo = _feeTo;\r\n    }\r\n\r\n    receive() external payable {\r\n        (bool s, ) = feeTo.call{value: msg.value}(\"\");\r\n        require(s);\r\n    }\r\n\r\n    /**\r\n     * @dev Registers new user\r\n     * @param user New user\r\n\r\n    */\r\n    function _addUser(address user, uint recordId) private {\r\n        assert(!access[user][recordId]);\r\n        access[user][recordId] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Implementation of ISafe.addUp\r\n     * See ISafe.addUp\r\n     */\r\n    function addUp(address user, uint recordId) external onlyRoleBearer returns (bool) {\r\n        unchecked {\r\n            userCount++;\r\n        }\r\n        _addUser(user, recordId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev UnLocks collateral balances\r\n     * @param user Existing user\r\n\r\n    */\r\n    function _removeUser(address user, uint recordId) private {\r\n        assert(access[user][recordId]);\r\n        if(userCount > 0) {\r\n            unchecked {\r\n                userCount--;\r\n            }\r\n        }\r\n        access[user][recordId] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve spender contributor 'to' to spend from contract's balance\r\n     * @param to : Contributor\r\n     * @param asset : Currency in use\r\n     * @param amount : Value\r\n     * @notice Consideration is given to the previous allowances given to users.\r\n     */\r\n    function _setAllowance(address to, IERC20 asset, uint256 amount) private {\r\n        uint prev = IERC20(asset).allowance(address(this), to);\r\n        unchecked {\r\n            IERC20(asset).approve(to, amount + prev);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev End the current epoch\r\n     * @param baseAsset : AssetBase\r\n     * @param data : Contributors data\r\n     * @param unit : Unit contribution\r\n     */\r\n    function _tryRoundUp(\r\n        IERC20 baseAsset,\r\n        uint unit,\r\n        uint96 recordId,\r\n        Common.Contributor[] memory data\r\n    ) internal {\r\n        uint erc20Balances = IERC20(baseAsset).balanceOf(address(this));\r\n        uint fees = aggregateFee;\r\n        unchecked {\r\n            if(erc20Balances > 0) {\r\n                if(fees > 0 && erc20Balances > fees) {\r\n                    erc20Balances -= fees;\r\n                    aggregateFee = 0;\r\n                    if(!IERC20(baseAsset).transfer(feeTo, fees)) 'Fee transfer failed'._throw();\r\n                }\r\n                if(erc20Balances > 0) {\r\n                    for(uint i = 0; i < data.length; i++) {\r\n                        erc20Balances -= _settleAccruals(data[i], unit, recordId, baseAsset);\r\n                    }\r\n                    if(erc20Balances > 0) {\r\n                        if(!IERC20(baseAsset).transfer(feeTo, erc20Balances)) 'Fee2 transfer failed'._throw();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        userCount = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Get Finance - We send USD to user and accept collateral.\r\n     * @param user : Beneficiary.\r\n     * @param baseAsset : Asset base\r\n     * @param loan : Amount to receive as loan.\r\n     * @param fee : Amount charged as platform fee\r\n     * @param calculatedCol : Amount required to pay as collateral\r\n     * @param recordId : Record Id\r\n     */\r\n    function getFinance(\r\n        address user,\r\n        IERC20 baseAsset,\r\n        uint256 loan,\r\n        uint fee,\r\n        uint256 calculatedCol,\r\n        uint recordId\r\n    ) external hasAccess(user, recordId) onlyRoleBearer returns(bool) {\r\n        assert(address(baseAsset) != address(0) && user != address(0));\r\n        collateralBalances[user][recordId] = calculatedCol;\r\n        uint loanable = loan;\r\n        if (fee > 0) {\r\n            unchecked {\r\n                aggregateFee += fee;\r\n                if (loanable > fee) {\r\n                    loanable -= fee;\r\n                }\r\n            }\r\n        }\r\n        _setAllowance(user, baseAsset, loanable);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Pays back loan\r\n     * @param _p : Parameters of type PaybackParam\r\n     * _p.user : Current txn.origin not msg.sender\r\n     * _p.baseAsset : Asset base\r\n     * _p.debt : Amount owing by user\r\n     * _p.attestedInitialBal : Initial recorded balance of this contract before asset was transfered from the user.\r\n     * _p.allGF : Whether all the contributors have get finance or not\r\n     * _p.cData : Contributors data\r\n     * _p.isSwapped : If isSwapped is true, meaning the actual contributor defaulted.\r\n     * _p.defaulted : Address of the defaulted\r\n     * _p.collaterAsset: Asset used as collateral\r\n     * _p.recordId : Record Id. Every pool has a record Id i.e pool.bigInt.recordId\r\n     */\r\n    function payback(Common.Payback_Safe memory _p, uint unit) \r\n        external \r\n        onlyRoleBearer \r\n        hasAccess(_p.isSwapped? _p.defaulted : _p.user, _p.recordId) \r\n        returns (uint col) \r\n    {\r\n        col = collateralBalances[_p.user][_p.recordId];\r\n        if (_p.isSwapped) {\r\n            col = collateralBalances[_p.defaulted][_p.recordId];\r\n            collateralBalances[_p.defaulted][_p.recordId] = 0;\r\n            _removeUser(_p.defaulted, _p.recordId);\r\n        } else {\r\n            _removeUser(_p.user, _p.recordId);\r\n        }\r\n        collateralBalances[_p.user][_p.recordId] = 0;\r\n        paybacks[_p.user] = _p.debt;\r\n        unchecked {\r\n            totalAmountIn += _p.debt;\r\n        }\r\n        assert(IERC20(_p.baseAsset).balanceOf(address(this)) >= (_p.attestedInitialBal + _p.debt));\r\n        _setAllowance(_p.user, _p.collateralAsset, col);\r\n        if(_p.allGF) _tryRoundUp(_p.baseAsset, unit, _p.recordId, _p.cData);\r\n        return col;\r\n    }\r\n\r\n    /**\r\n     * @dev Settles all pending loans and interests due to providers provided the contributor \r\n     *      joined via providers' services.\r\n     * @notice The amount paid back by the contributor should be enough to settle the providers.\r\n     * @param data : Profile of the current contributor.\r\n     * @param unit : Unit contribution\r\n     * @param baseAsset : Asset used as contribution currency\r\n     */\r\n    function _settleAccruals(\r\n        Common.Contributor memory data, \r\n        uint unit, \r\n        uint96 recordId,\r\n        IERC20 baseAsset\r\n    ) internal returns(uint totalPaidOut) {\r\n        uint amtLeft = paybacks[data.id];\r\n        Common.Provider[] memory providers = IFactory(_msgSender()).getContributorProviders(data.id, recordId);\r\n        unchecked {\r\n            if(providers.length > 0) {\r\n                for(uint i = 0; i < providers.length; i++) {\r\n                    uint providerPay = providers[i].amount + (providers[i].accruals.intPerSec * (data.paybackTime - providers[i].earnStartDate));\r\n                    assert(amtLeft >= providerPay);\r\n                    amtLeft -= providerPay;\r\n                    _setAllowance(providers[i].account, baseAsset, providerPay);\r\n                }\r\n                totalPaidOut += amtLeft;\r\n            } else {\r\n                totalPaidOut += unit;\r\n                _setAllowance(data.id, baseAsset, unit);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called when a contributor remove a pool\r\n     * @param user : Contributor\r\n     * @param baseAsset : Asset base\r\n     * @param unit : Unit contribution\r\n     * @param recordId : Record Id\r\n     */\r\n    function cancel(\r\n        address user,\r\n        IERC20 baseAsset,\r\n        uint unit,\r\n        uint recordId\r\n    ) external onlyRoleBearer hasAccess(user, recordId) returns (bool) {\r\n        _setAllowance(user, baseAsset, unit);\r\n        _removeUser(user, recordId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Safe-related data\r\n     */\r\n    function getData() external view returns (ViewData memory) {\r\n        return ViewData(userCount, aggregateFee);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns User-related data\r\n     * @param user : Contributor\r\n     * @param recordId : Record Id\r\n     */\r\n    function getUserData(\r\n        address user,\r\n        uint recordId\r\n    ) external view returns (ViewUserData memory) {\r\n        return ViewUserData(access[user][recordId], collateralBalances[user][recordId]);\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/standalone/SafeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { ISafeFactory } from \"../apis/ISafeFactory.sol\";\r\nimport { Safe, OnlyRoleBase, IRoleBase } from \"../peripherals/Safe.sol\";\r\n\r\n/**@title SafeFactory: A standalone contract that manages safe creation and retrieval, \r\n  deletion, read and write data.\r\n */\r\ncontract SafeFactory is ISafeFactory, OnlyRoleBase {\r\n  // using Clones for address;\r\n\r\n  // Total safe created to date\r\n  uint public totalSafes;\r\n\r\n  // Fee receiver account\r\n  address public feeTo;\r\n\r\n /**\r\n * @dev Mapping of unit contribution to safe.\r\n */\r\n  mapping(uint256 unitContribution => address safeAddresses) private safeMap;\r\n\r\n  /**\r\n   * =========== Constructor ===============\r\n   * @param _roleManager : Role manager contract\r\n   * @param _feeTo : Fee receiver\r\n   */\r\n  constructor (IRoleBase _roleManager, address _feeTo) OnlyRoleBase(_roleManager) {\r\n    feeTo = _feeTo;\r\n  }\r\n\r\n  // Not accepting values\r\n  receive() external payable {\r\n    revert();\r\n  }\r\n  \r\n  /**@dev Return if account owns a safe or not\r\n  */\r\n  function _hasSafe(uint256 unit) internal view returns (bool) {\r\n    return safeMap[unit] != address(0);\r\n  }\r\n\r\n  // Returns Safe for 'user'\r\n  function _getSafe(uint256 unit) internal view returns(address) { \r\n    return safeMap[unit];\r\n  }\r\n  \r\n  /**@dev Create a new safe.\r\n   * @notice 'unit' should not own a safe before now.\r\n   *          only address with owner permission can call.\r\n  */\r\n  function pingSafe(uint256 unit) external onlyRoleBearer returns(address _safe) {\r\n    if(!_hasSafe(unit)){\r\n      _safe = _createSafe(unit);\r\n    } else {\r\n      _safe = _getSafe(unit);\r\n    }\r\n    return _safe;\r\n  }\r\n\r\n  /** @dev Creates a new Safe\r\n  * @param unit : Amount\r\n  * @notice Even if user is trying to rekey or upgrade smartsafe, same amount of fee is required\r\n  * for successful upgrade.\r\n  */\r\n  function _createSafe(uint256 unit) private returns(address safe) {\r\n    totalSafes ++;\r\n    safe = address(new Safe(roleManager, feeTo));\r\n    _updateSafe(unit, safe);\r\n  }\r\n\r\n  /**\r\n   * Update storage with the new Safe instance : {internal}\r\n   * @param unit : Unit amount \r\n   * @param safe : New Safe address\r\n   */\r\n  function _updateSafe(uint256 unit, address safe) private {\r\n    safeMap[unit] = safe;\r\n  }\r\n\r\n  /**\r\n    * Returns then safe for 'unit'\r\n    * @param unit : Unit amount\r\n  */\r\n  function getSafe(uint unit) external view returns(address) { \r\n    return _getSafe(unit);\r\n  }\r\n\r\n  function setFeeTo(address newFeeTo) public onlyRoleBearer {\r\n    feeTo = newFeeTo;\r\n  }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "constantinople",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}