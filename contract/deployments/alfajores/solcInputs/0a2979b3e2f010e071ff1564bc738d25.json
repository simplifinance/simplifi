{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@thirdweb-dev/contracts/external-deps/openzeppelin/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@thirdweb-dev/contracts/external-deps/openzeppelin/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/apis/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IERC20 } from './IERC20.sol';\r\n\r\ninterface Common {\r\n    event PoolCreated(Pool);\r\n    event NewContributorAdded(Pool);\r\n    event GetFinanced(Pool);\r\n    event Payback(Pool);\r\n    event Liquidated(Pool);\r\n    event Cancellation(uint unit);\r\n    event PoolEdited(Pool);\r\n\r\n    enum Stage {\r\n        JOIN, \r\n        GET, \r\n        PAYBACK, \r\n        CANCELED,\r\n        ENDED\r\n    }\r\n\r\n    enum Status { AVAILABLE, TAKEN }\r\n\r\n    enum Branch { CURRENT, RECORD }\r\n\r\n    enum Router { NONE, PERMISSIONLESS, PERMISSIONED }\r\n\r\n    struct Pool {\r\n        Low low;\r\n        Big big;\r\n        Addresses addrs;\r\n        Router router;\r\n        Stage stage;\r\n        Status status;\r\n    }\r\n\r\n    struct Low {\r\n        uint8 maxQuorum;\r\n        uint8 selector;\r\n        uint24 colCoverage;\r\n        uint32 duration;\r\n        uint8 allGh;\r\n        uint8 userCount;\r\n    }\r\n\r\n    struct Big {\r\n        uint256 unit;\r\n        uint256 currentPool;\r\n        uint96 recordId;\r\n        uint96 unitId;\r\n    }\r\n\r\n    struct Point {\r\n        uint contributor;\r\n        uint creator;\r\n        uint referrals;\r\n        address user;\r\n    }\r\n\r\n    struct Interest {\r\n        uint fullInterest;\r\n        uint intPerSec;\r\n    }\r\n\r\n    /**\r\n     * @notice Structured types - Address\r\n     * @param asset : Contract address of the asset in use.\r\n     * @param lastPaid: Last contributor who got finance.\r\n     * @param safe : Strategy for each pool or epoch. See Strategy.sol for more details.\r\n     * @param admin : Pool creator.\r\n     * \r\n    */\r\n    struct Addresses {\r\n        IERC20 colAsset;\r\n        address lastPaid;\r\n        address safe;\r\n        address admin;\r\n    }\r\n\r\n    /**\r\n     *  @param isMember : Whether user is a member or not\r\n     *  @param turnStartTime: Time when the contributor's turn start to count.\r\n     *  @param getFinanceTime: Date when loan was disbursed\r\n     *  @param paybackTime: Date which the borrowed fund must be retured\r\n     *  @param loan: Total debts owed by the last fund recipient.\r\n     *  @param colBals: Collateral balances of the last recipient.\r\n     *  @param sentQuota : Whether an user/current msg.sender has received or not.\r\n     *  @param id : Address of the last recipient.\r\n     * @param interestPaid : The amount of interest paid  \r\n    */\r\n    struct Contributor {\r\n        uint32 paybackTime;\r\n        uint32 turnStartTime;\r\n        uint32 getFinanceTime;\r\n        uint loan;\r\n        uint colBals;\r\n        address id;\r\n        bool sentQuota;\r\n    }\r\n\r\n    struct Price {\r\n        uint128 price;\r\n        uint8 decimals;\r\n    }\r\n\r\n    struct Provider {\r\n        uint slot;\r\n        uint amount;\r\n        uint rate;\r\n        uint earnStartDate;\r\n        address account;\r\n        Interest accruals;\r\n    }\r\n\r\n    struct Payback_Safe {\r\n        address user; \r\n        IERC20 baseAsset; \r\n        uint256 debt;\r\n        uint256 attestedInitialBal;\r\n        bool allGF; \r\n        Contributor[] cData;\r\n        bool isSwapped;\r\n        address defaulted;\r\n        uint96 recordId;\r\n        IERC20 collateralAsset;\r\n    }\r\n\r\n    struct Slot {\r\n        uint value;\r\n        bool isMember;\r\n        bool isAdmin;\r\n    }\r\n\r\n    struct ReadPoolDataReturnValue {\r\n        Pool pool;\r\n        ContributorReturnValue[] cData;\r\n    }\r\n\r\n    struct ReadRecordDataReturnValue {\r\n        Pool pool;\r\n        Contributor[] cData;\r\n    }\r\n\r\n    struct UpdatePoolData {\r\n        uint unit;\r\n        uint96 unitId;\r\n        uint96 recordId;\r\n        uint8 maxQuorum;\r\n        uint24 colCoverage;\r\n        IERC20 colAsset;\r\n        uint16 durationInHours;\r\n        address creator;\r\n        Router router; \r\n    }\r\n\r\n    struct Analytics {\r\n        uint256 tvlCollateral;\r\n        uint256 tvlBase;\r\n        uint totalPermissioned;\r\n        uint totalPermissionless;\r\n    }\r\n\r\n    struct ViewFactoryData {\r\n        Analytics analytics;\r\n        uint16 makerRate;\r\n        uint currentEpoches;\r\n        uint recordEpoches;\r\n    }\r\n\r\n    struct ContributorReturnValue {\r\n        Contributor profile;\r\n        Slot slot;\r\n        Common.Provider[] providers;\r\n    }\r\n\r\n}"
    },
    "contracts/apis/IDIAOracleV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\ninterface IDIAOracleV2 {\r\n    function getValue(string memory key) \r\n        external \r\n        view \r\n        returns(uint128 price, uint128 timestamp);\r\n}"
    },
    "contracts/apis/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport \"./IERC20Metadata.sol\";\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 is IERC20Metadata{\r\n    error NotCallable();\r\n    error AddressIsZero(address);\r\n    error NoPreviousLockDetected();\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    \r\n    /** \r\n     * @dev Moves `amounts` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event for each transfer.\r\n     * Note: BE AWARE OF THE GAS COST WHEN USING THIS FUNCTION. IT INCREASES \r\n                RELATIVE TO THE ACCOUNTS ARRAY\r\n     */\r\n    function batchTransfer(uint[] memory amounts, address[] memory accounts) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n\r\n    /**@dev Locks specific amount of JFT to the private ledger.\r\n        param: routeTo - Alternative address that funds will be sent to when panic call is made.\r\n        param: amount - Amount to lock.\r\n    */\r\n    function lockToken(address routeTo, uint256 amount) external returns(bool);\r\n\r\n    /**@dev Moves an 'amount' from private ledger to regular balances.\r\n        @param amount - Amount to unlock.\r\n        Note: If the lock duration was set, holder will not be able to unlock until the \r\n            set time has passed else they can withdraw to regular balance anytime.\r\n     */\r\n    function unlockToken(uint amount) external returns(bool);\r\n\r\n    /** @dev Returns seperate balances of @param who\r\n        return value will be in struct format having two values\r\n     */\r\n    function accountBalances(address who) external view returns(Balances memory);\r\n   \r\n    // /**@dev Return JFT's Metadata including the information of `who`\r\n    //  */\r\n    // function getInfo(address who) external view returns(Protected memory);\r\n\r\n    /**\r\n     * @dev PanicUnlock is meant to be invoked only by the Attorney.\r\n     * It should only be called when JFT holder has lost access to their account and they had \r\n     * earlier initiated a lock. The locked token is simply unlocked and sent to an escape address\r\n     * provided at the time the lock was activated.\r\n     * \r\n     * Note: Attorney charges a fee for doing this. \r\n     * @param account : Account that owns this token.\r\n     */\r\n    function panicUnlock(address account, Balances memory _bal) external returns(bool);\r\n\r\n    struct Protected {\r\n        uint256 value; // Total value currently locked\r\n        address escapeTo;\r\n    }\r\n\r\n    struct Balances {\r\n        uint256 spendable;\r\n        Protected locked;\r\n    }\r\n\r\n    struct TokenInfo {\r\n        uint8 decimals;\r\n        uint256 totalSupply;\r\n        string name;\r\n        string symbol;\r\n        address attorney;\r\n        // address rewarder;\r\n    }\r\n}\r\n"
    },
    "contracts/apis/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "contracts/apis/IFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"./Common.sol\";\r\n\r\ninterface IFactory is Common {\r\n  function contributeThroughProvider(Provider[] memory providers, address borrower, uint unit) external returns(bool);\r\n  function getContributorProviders(address target, uint96 recordId) external view returns(Provider[] memory);\r\n}"
    },
    "contracts/apis/IPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"./Common.sol\";\r\n/**\r\n * @title Simplifi\r\n * @author : Bobeu - https://github.com/bobeu\r\n * @notice : Interface of the Point contract for managing user's rewards and points.\r\n */\r\ninterface IPoint {\r\n  struct Initializer {\r\n    bool isRegistered;\r\n    uint location;\r\n  }\r\n\r\n  function getPoint(address user) external view returns(Common.Point memory);\r\n  function setPoint(address user, Common.Point memory) external returns(bool);\r\n  function deductPoint(address user, Common.Point memory) external returns(bool);\r\n}"
    },
    "contracts/apis/IRoleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title IRoleBase \r\n * Interface of the OwnerShip contract\r\n * @author Simplifi (Bobeu)\r\n */\r\ninterface IRoleBase {\r\n    function setRole(\r\n        address[] memory newRoleTos\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function removeRole(\r\n        address target\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function renounceRole() \r\n        external\r\n        returns(bool);\r\n\r\n    function getRoleBearer(\r\n        uint ownerId\r\n    ) \r\n        external \r\n        view \r\n        returns(address);\r\n\r\n    function hasRole(\r\n        address target\r\n    )\r\n        external\r\n        view \r\n        returns(bool);\r\n}"
    },
    "contracts/apis/ISafe.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"./Common.sol\";\r\nimport { IERC20 } from \"./IERC20.sol\";\r\n\r\ninterface ISafe {\r\n  function addUp(address user, uint recordId) external returns(bool);\r\n  function getFinance(\r\n    address user, \r\n    IERC20 baseAsset, \r\n    uint256 loan, \r\n    uint fee, \r\n    uint256 calculatedCol,\r\n    uint recordId\r\n  ) \r\n    external \r\n    returns(bool);\r\n\r\n  function payback(Common.Payback_Safe memory, uint unit) external returns(uint collateral);\r\n  function cancel(address user, IERC20 asset, uint unit, uint recordId) external returns(bool);\r\n  function getData() external view returns(ViewData memory);\r\n\r\n  struct ViewData {\r\n    uint totalClients;\r\n    uint aggregateFee;\r\n  }\r\n\r\n  struct ViewUserData {\r\n    bool access;\r\n    uint collateralBalance;\r\n  }\r\n}"
    },
    "contracts/apis/ISafeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title Interface of the Safe manager\r\n * @author : Simplifinance (Written by Bobeu)\r\n */\r\ninterface ISafeFactory {  \r\n  /**\r\n   * Query safe for user\r\n   * @param unit : Address to get safe for\r\n   * @return A safe if none was found, it returns address(0).\r\n   */\r\n  function getSafe(uint256 unit) external view returns(address);\r\n  // function getSafe(address user) external view returns(address);\r\n\r\n/**\r\n * Clones and return a new safe \r\n * @param unit : Target address for whom to create safe\r\n */\r\n  function pingSafe(uint256 unit) external returns(address safe);\r\n\r\n  /**\r\n   * Safe struct map\r\n   * key: user address { EOA }\r\n   * value: Safe { Contract } \r\n   */\r\n  struct SafeData {\r\n    address key;\r\n    address value;\r\n  }\r\n\r\n}"
    },
    "contracts/apis/ISupportedAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\ninterface ISupportedAsset {\r\n  function isSupportedAsset(address _asset) external view returns(bool);\r\n  function getDefaultSupportedCollateralAsset() external view returns(address _default);\r\n}"
    },
    "contracts/libraries/ErrorLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nlibrary ErrorLib {\r\n    error ErrorOccurred(string errorMsg);\r\n\r\n    /**\r\n     * @dev Reverts any operation.\r\n     * @param _error : Error struct\r\n     */\r\n    function _throw(string memory _error) internal pure {\r\n        if(bytes(_error).length > 0){ \r\n            revert ErrorOccurred(_error);\r\n        }\r\n    }\r\n\r\n}"
    },
    "contracts/libraries/Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport { Common } from \"../apis/Common.sol\";\r\nimport { ErrorLib } from \"./ErrorLib.sol\";\r\n\r\nlibrary Utils {\r\n    using Address for address;\r\n    using ErrorLib for *;\r\n\r\n    /**     @dev Calculation of percentage.\r\n        *   This is how we calculate percentage to arrive at expected value with \r\n        *   precision.\r\n        *   We choose a base value (numerator as 10000) repesenting a 100% of the principal value. This means if Alice wish to set \r\n        *   her interest rate to 0.05% for instance, she only need to multiply it by 100 i.e 0.05 * 100 = 5. Her input will be 5. \r\n        *   Since Solidity do not accept decimals as input, in our context, the minimum value to parse is '0' indicating \r\n        *   zero interest rate. If user wish to set interest at least, the minimum value will be 1 reprensenting 0.01%.\r\n        *   The minimum interest rate to set is 0.01% if interest must be set at least.\r\n        *   @notice To reiterate, raw interest must be multiplied by 100 before giving as input. \r\n        *   @param principal : The principal value on which the interest is based. Value should be in decimals.\r\n        *   @param interest : Interest rate. \r\n        *   \r\n        *   Rules\r\n        *   -----\r\n        *   - Principal cannot be less than base.\r\n        *   - Interest cannot be greater than (2 ^ 16) - 1\r\n    */\r\n    function _getPercentage(\r\n        uint principal, \r\n        uint16 interest\r\n    )\r\n        internal \r\n        pure \r\n        returns (uint _return) \r\n    {\r\n        uint16 base = _getBase(); \r\n        if(interest == 0 || principal == 0) return 0;\r\n        if(interest >= type(uint16).max) 'Interest overflow'._throw(); \r\n        if(principal <= base) 'Principal should be greater than 10000'._throw();\r\n        unchecked {\r\n            _return = (principal * interest) / base;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Percentage base\r\n     */\r\n    function _getBase() internal pure returns(uint16 base) {\r\n        base = 10000;\r\n    }\r\n    \r\n    function _decimals(address asset) internal view returns(uint8 decimals) {\r\n        decimals = IERC20Metadata(asset).decimals();\r\n    }\r\n\r\n    /**\r\n     * @dev Computes collateral on the requested loan amount\r\n     * @param ccr : Collateral ratio. Must be multiply by 100 before parsing as input i.e if raw ccr\r\n     *              is 1.2, it should be rendered as 1.2 * 100 = 120.\r\n     * @param price : Price of Collateral token base with decimals.\r\n     * @param loanReqInDecimals : Total requested contribution in USD\r\n     * @notice Based on Simplifi mvp, loans are collaterized in XFI until we add more pairs\r\n     *         in the future.\r\n     * Example: Alice, Bob and Joe formed a band to contribute $100 each where duration is for \r\n     * 10 days each. Alice being the admin set ccr to 1.5 equivalent to 150% of the total sum \r\n     * contribution of $300. If the price of XFI as at the time of GF is $0.5/XFI, where XFI decimals\r\n     * is in 18, we calculate the required XFI to stake as follows:   \r\n     *  \r\n     *                    totalContribution *  (10** XFIdecimals)   |                 raw ccr\r\n     *   totalLoanInXFI = --------------------------------------    |    actualCCR = (1.5 * 100) * 100 = 1500\r\n     *                        (xfiPriceIndecimals)                  |\r\n     * \r\n     *                     totalLoanInXFI * actualCCR\r\n     *        XFINeeded = ----------------------------\r\n     *                             _getBase()\r\n     * \r\n     *  Therefore, Alice is required to stake 900XFI to GF $300 for 10 days.\r\n     *   \r\n     */\r\n    function computeCollateral(\r\n        Common.Price memory price,\r\n        uint24 ccr,\r\n        uint loanReqInDecimals\r\n    ) \r\n        internal\r\n        pure \r\n        returns(uint256 expCol) \r\n    {\r\n        // uint8 minCCR = 100;\r\n        // if(ccr < minCCR) revert CollateralCoverageCannotGoBelow_100();\r\n        if(ccr == 0) expCol = 0;\r\n        else {\r\n            unchecked {\r\n                uint48 _ccr = uint48(ccr * 100);\r\n                uint totalLoan = (loanReqInDecimals * (10**price.decimals)) / price.price;\r\n                expCol = (totalLoan * _ccr) / _getBase();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @dev Computes maker fee.\r\n        @param makerRate : The amount of fee (in %) charged by the platform on the principal given to a borrower.\r\n            Note : Raw rate must multiply by 100 to get the expected value i.e\r\n            if maker rate is 0.1%, it should be parsed as 0.1 * 100 = 10.\r\n            See `_getPercentage()`.\r\n        @param amount should be in decimals.\r\n    */\r\n    function computeFee(\r\n        uint amount, \r\n        uint16 makerRate\r\n    ) \r\n        internal \r\n        pure \r\n        returns (uint mFee) \r\n    {\r\n        mFee = _getPercentage(amount, makerRate);\r\n    }\r\n\r\n    /**\r\n     * @dev Compute interest based on specified rate.\r\n     * @param rate : Interest rate.\r\n     * @param principal : Total expected contribution.\r\n     * @param fullDurationInSec : Total duration.\r\n     * \r\n     * Rules\r\n     * -----\r\n     * - Duration cannot exceed 30days i.e 2592000 seconds uint24 seconds\r\n     */\r\n    function computeInterestsBasedOnDuration(\r\n        uint principal,\r\n        uint16 rate,\r\n        uint32 fullDurationInSec\r\n    )\r\n        internal \r\n        pure \r\n        returns(Common.Interest memory it) \r\n    {\r\n        assert(fullDurationInSec <= _maxDurationInSec());\r\n        it.fullInterest = _getPercentage(principal, rate); // Full interest for fullDurationInSec\r\n        if(it.fullInterest > 0) {\r\n            unchecked {\r\n                it.intPerSec = (it.fullInterest * 1) / fullDurationInSec;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Max duration : 30Days, presented in seconds\r\n     */\r\n    function _maxDurationInSec() internal pure returns(uint24 max) {\r\n        max = 2592000;\r\n    }\r\n\r\n    function _now() internal view returns(uint64 date) {\r\n        date = uint64(block.timestamp);\r\n    }\r\n\r\n}"
    },
    "contracts/peripherals/AwardPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IPoint } from \"../apis/IPoint.sol\";\r\nimport { Common } from \"../apis/Common.sol\";\r\nimport { Price, IRoleBase, ErrorLib, IERC20, ISupportedAsset, ISafeFactory } from './Price.sol';\r\n\r\nabstract contract AwardPoint is Price {\r\n    using ErrorLib for *;\r\n\r\n    // Whether to award point to users or not\r\n    bool public awardPoint;\r\n\r\n    // Point factory address\r\n    IPoint public immutable pointFactory;\r\n\r\n    /**\r\n     * ================ Constructor ==============\r\n     * @param _roleManager : Role manager contract\r\n     * @param _pointFactory : Point Factory contract\r\n     */\r\n    constructor(\r\n        IRoleBase _roleManager, \r\n        IPoint _pointFactory,\r\n        IERC20 _baseAsset,\r\n        address _diaOracleAddress, \r\n        ISupportedAsset _assetManager,\r\n        ISafeFactory _safeFactory\r\n    ) \r\n        Price(_diaOracleAddress, _assetManager, _roleManager, _baseAsset, _safeFactory)\r\n    {\r\n        if(address(_pointFactory) == address(0)) 'IPointFactory is zero'._throw();\r\n        awardPoint = true;\r\n        pointFactory = _pointFactory;\r\n    }\r\n\r\n    ///@dev Award points for users\r\n    function _awardPoint(address target, uint8 asMember, uint8 asAdmin, bool deduct) internal {\r\n        (bool done, Common.Point memory point) = (false, Common.Point(asMember, asAdmin, 0, target));\r\n        done = deduct? IPoint(pointFactory).deductPoint(target, point) : IPoint(pointFactory).setPoint(target, point);\r\n        if(!done) 'Point award failed'._throw();\r\n    }\r\n\r\n    /// @dev Activate reward\r\n    function activateReward() public onlyRoleBearer returns(bool) {\r\n        if(awardPoint) 'Reward is active'._throw();\r\n        awardPoint = true;\r\n        return true;\r\n    }\r\n\r\n    /// @dev Deactivate reward\r\n    function deactivateReward() public onlyRoleBearer returns(bool) {\r\n        if(!awardPoint) 'Reward is inActive'._throw();\r\n        awardPoint = false;\r\n        return true;\r\n    }\r\n\r\n}"
    },
    "contracts/peripherals/Contributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Epoches, Common } from \"./Epoches.sol\";\r\nimport { Slots } from \"./Slots.sol\" ;\r\nimport { Utils } from \"../libraries/Utils.sol\";\r\nimport { AwardPoint, IRoleBase, IERC20, ErrorLib, IPoint, ISupportedAsset, ISafeFactory } from \"./AwardPoint.sol\";\r\nimport { ISafe } from \"../apis/ISafe.sol\";\r\n\r\nabstract contract Contributor is Epoches, Slots, AwardPoint {\r\n    using ErrorLib for *;\r\n    using Utils for *;\r\n\r\n    /**\r\n     * @dev Mapping of recordId to contributors\r\n     * @notice We used record Id to index the contributors in a pool while a unit contribution\r\n     * van have multiple records, it makes sense to track contributors in each pool with their record Id\r\n    */\r\n    mapping(uint96 => Common.Contributor[]) private contributors;\r\n\r\n    /**\r\n     * @dev Mapping of record ids to contributors to array of providers\r\n     * @notice Each contributor can maintain a list of providers they borrow from\r\n     */\r\n    mapping(uint96 => mapping(address => Common.Provider[])) private unitProviders;\r\n\r\n    // ============= constructor ============\r\n    constructor(\r\n        address _diaOracleAddress, \r\n        ISupportedAsset _assetManager, \r\n        IRoleBase _roleManager,\r\n        IERC20 _baseAsset,\r\n        IPoint _pointFactory,\r\n        ISafeFactory _safeFactory\r\n    ) \r\n       AwardPoint(_roleManager, _pointFactory, _baseAsset, _diaOracleAddress, _assetManager, _safeFactory)\r\n    {}\r\n\r\n    /**\r\n     * @dev Only contributor in a pool is allowed\r\n     * @param target : Target\r\n     * @param unit : Unit Contribution\r\n    */\r\n    function _onlyContributor(address target, uint256 unit, bool pass) internal view {\r\n        if(!pass){\r\n            if(!_getSlot(target, unit).isMember) 'Not a member'._throw();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Only Non contributor in a pool is allowed\r\n     * @param target : Target\r\n     * @param unit : Unit Contribution\r\n     */\r\n    function _onlyNonContributor(address target, uint256 unit) internal view {\r\n        if(_getSlot(target, unit).isMember) 'Member not allowed'._throw();\r\n    }\r\n\r\n    /**\r\n     * @dev returns target's profile status in a pool\r\n     * @param target : Target account\r\n     * @param unit : Unit contribution\r\n     */\r\n    function _getContributor(\r\n        address target, \r\n        uint unit\r\n    ) internal view returns(Common.ContributorReturnValue memory result) {\r\n        uint96 recordId = _getRecordId(unit);\r\n        result.slot = _getSlot(target, unit);\r\n        result.profile = contributors[recordId][result.slot.value];\r\n        result.providers = _getContributorProviders(target, recordId);\r\n    }\r\n\r\n    /**\r\n     * @dev Return providers associated with the target account\r\n     * @param target : Target account\r\n     * @param recordId : Record id\r\n     */\r\n    function _getContributorProviders(address target, uint96 recordId) internal view returns(Common.Provider[] memory result){\r\n        result = unitProviders[recordId][target];\r\n    }\r\n\r\n    /**\r\n     * @dev returns user's profile status in a pool\r\n     * @param unit : Unit contribution\r\n     */\r\n    function _getExpected(uint256 unit, uint8 selector) internal view returns(Common.Contributor memory _expected) {\r\n        _expected = contributors[_getRecordId(unit)][selector];\r\n    }\r\n\r\n    /**\r\n     * @dev Update the provider list of a contributor\r\n     * @param providers : List of providers\r\n     * @param user : Target user\r\n     * @param recordId : Record Id\r\n     */\r\n    function _setProviders(\r\n        Common.Provider[] memory providers, \r\n        address user, \r\n        uint96 recordId\r\n    ) internal {\r\n        for(uint i = 0; i < providers.length; i++){\r\n            unitProviders[recordId][user].push(providers[i]);\r\n        }\r\n    } \r\n\r\n    /**\r\n     * @dev Set user's time to get finance\r\n     * @param user : Target address\r\n     * @param unit : Unit contribution\r\n     * @param date : Date/timestamp\r\n     * @notice If 'user' is zero address, we generate a new slot otherwise fetch existing slot\r\n     */ \r\n    function _setTurnStartTime(address user, uint256 unit, uint32 date) internal {\r\n        uint position;\r\n        if(user == address(0)){\r\n            position = _getPool(unit).low.selector;\r\n            user = _getExpected(unit, uint8(position)).id;\r\n        } else {\r\n            position = _getSlot(user, unit).value;\r\n        }\r\n        contributors[_getRecordId(unit)][position].turnStartTime = date;\r\n     }\r\n\r\n    /**\r\n     * @dev Add or update contributor to the list of contributors\r\n     * @param profile : Target profile\r\n     * @param position : The position of target user in the list\r\n     * @param recordId : Unit Id\r\n     */\r\n    function _setContributor(Common.Contributor memory profile, uint96 recordId, uint8 position, bool setEmpty) internal {\r\n        Common.Contributor memory empty;\r\n        contributors[recordId][position] = setEmpty? empty : profile;\r\n    }\r\n\r\n    /**\r\n     * @dev Add contributor data to storage\r\n     * @param pool : Pool struct\r\n     * @param unit : Unit contribution\r\n     * @param target : Target user\r\n     * @param isAdmin : Whether user is the creator or not\r\n     * @param isMember : Whether user is a member or not\r\n     * @param sentQuota : Whether user have sent their quota of the contribution or not\r\n     */\r\n    function _initializeContributor(\r\n        Common.Pool memory pool,\r\n        uint256 unit,\r\n        address target,\r\n        bool isAdmin,\r\n        bool isMember,\r\n        bool sentQuota            \r\n    ) internal returns(Common.ContributorReturnValue memory data) {\r\n        data.slot.value = contributors[pool.big.recordId].length;\r\n        _createSlot(target, unit, uint8(data.slot.value), isAdmin, isMember);\r\n        contributors[pool.big.recordId].push(); \r\n        data.profile.id = target;\r\n        data.profile.sentQuota = sentQuota;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove contributor from a pool\r\n     * @param target : Target address\r\n     * @param unit : Unit contribution\r\n     * @notice Parsing true to _setSlot as the last argument with set the slot to empty\r\n     */\r\n    function _removeContributor(address target, uint256 unit) internal {\r\n        Common.Slot memory slot = _getSlot(target, unit);\r\n        _setSlot(target, unit, slot, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Swaps contributors data if the expected caller is not the same as the actual caller\r\n     * and the grace period has elapsed.\r\n     * @param unit : Unit contribution\r\n     * @param actual : Actual calling account\r\n     * @param expectedSlot : Slot of expected calling account\r\n     * @param expectedData : Data of expected calling account\r\n     */\r\n    function _swapContributors(\r\n        uint256 unit,\r\n        address actual,\r\n        Common.Slot memory expectedSlot,\r\n        Common.Contributor memory expectedData\r\n    )\r\n        internal\r\n        returns(Common.Contributor memory actualData) \r\n    {\r\n        _onlyContributor(actual, unit, false);\r\n        uint96 recordId = _getRecordId(unit);\r\n        Common.Slot memory actualSlot = _getSlot(actual, unit);\r\n        actualData = _getContributor(actual, unit).profile;\r\n        _setSlot(actual, unit, expectedSlot, false);\r\n        _setSlot(expectedData.id, unit, actualSlot, false);\r\n        expectedData.id = actual;\r\n        actualData.id = expectedData.id;\r\n        _setContributor(expectedData, recordId, uint8(expectedSlot.value), false);\r\n        _setContributor(actualData, recordId, uint8(actualSlot.value), false);\r\n    }\r\n\r\n    /**\r\n     * @dev Complete the getFinance task\r\n     * @param pool : Existing pool. Must not be an empty pool.\r\n     * @param collateral : Expected collateral\r\n     * @param profile : User's profile data\r\n     */\r\n    function _completeGetFinance(Common.Pool memory pool, uint collateral, Common.Contributor memory profile) internal returns(Common.Pool memory _pool, Common.Contributor memory _profile) {\r\n        pool.low.selector ++;\r\n        unchecked {\r\n            profile.paybackTime = _now() + pool.low.duration;\r\n        }\r\n        profile.colBals = collateral;\r\n        profile.loan = pool.big.currentPool;\r\n        Common.Provider[] memory providers = unitProviders[pool.big.recordId][pool.addrs.lastPaid];\r\n        for(uint i = 0; i < providers.length; i++){\r\n            unitProviders[pool.big.recordId][pool.addrs.lastPaid][i].earnStartDate = _now();\r\n            unitProviders[pool.big.recordId][pool.addrs.lastPaid][i].accruals = providers[i].amount.computeInterestsBasedOnDuration(uint16(providers[i].rate), pool.low.duration);\r\n        }\r\n        pool.big.currentPool = 0;\r\n        pool.stage = Common.Stage.PAYBACK;\r\n        _pool = pool;\r\n        _profile = profile;\r\n    }\r\n\r\n    /**\r\n     * @dev Payback loan\r\n     * @param unit : Unit contribution\r\n     * @param payer : Contributor\r\n     * @param isSwapped : Whether there was swapping or not. Often swapping will happen when a contributor defaults\r\n     * @param defaulter : The defaulter account\r\n     */\r\n    function _payback(\r\n        uint unit, \r\n        address payer,\r\n        bool isSwapped,\r\n        address defaulter\r\n    ) \r\n        internal\r\n        _onlyIfUnitIsActive(unit)\r\n        returns(Common.Pool memory pool, uint debt, uint collateral)\r\n    {\r\n        (debt, pool) = _getCurrentDebt(unit);\r\n        if(debt == 0) 'No debt found'._throw();\r\n        uint slot = _getSlot(pool.addrs.lastPaid, unit).value;\r\n        contributors[pool.big.recordId][slot].loan = 0;\r\n        contributors[pool.big.recordId][slot].colBals = 0;\r\n        contributors[pool.big.recordId][slot].paybackTime = _now();\r\n        if(awardPoint) _awardPoint(pool.addrs.lastPaid, 2, 0, false);\r\n        if(pool.low.maxQuorum == pool.low.allGh){\r\n            pool.stage = Common.Stage.ENDED;\r\n            _shufflePool(pool);\r\n        } else {\r\n            contributors[pool.big.recordId][pool.low.selector].turnStartTime = _now();\r\n            pool.stage = Common.Stage.GET;\r\n            unchecked {\r\n                pool.big.currentPool = pool.big.unit * pool.low.maxQuorum;\r\n            }\r\n            _setPool(pool.big.unitId, pool);\r\n        }\r\n        uint attestedInitialBal = IERC20(baseAsset).balanceOf(pool.addrs.safe);\r\n        _checkAndWithdrawAllowance(IERC20(baseAsset), payer, pool.addrs.safe, debt);\r\n        collateral = ISafe(pool.addrs.safe).payback(\r\n            Common.Payback_Safe(payer, baseAsset, debt, attestedInitialBal, pool.low.maxQuorum == pool.low.allGh, contributors[pool.big.recordId], isSwapped, defaulter, pool.big.recordId, pool.addrs.colAsset),\r\n            unit\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Return past pools using unitId. \r\n     * @notice The correct unitId must be parsed. \r\n     * @param recordId: Record Id\r\n     * @notice The record id can be obtained by iterating over the past epoches. Using the record Id\r\n     * associated with the current pool will return empty pool but may not return empty contributors.\r\n     */\r\n    function getPoolRecord(uint96 recordId) public view returns(Common.ReadPoolDataReturnValue memory result) {\r\n        result = _getPoolData(_getPastPool(recordId));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return past pools using unitId. \r\n     * @notice For every unit contribution, the unit Id is unique to another and does not change\r\n     * @param unitId: UnitId \r\n    */\r\n    function getPoolData(uint96 unitId) public view returns(Common.ReadPoolDataReturnValue memory result) {\r\n        result = _getPoolData(_getPoolWithUnitId(unitId));\r\n        return result;\r\n    }\r\n\r\n    function _getPoolData(Common.Pool memory pool) internal view returns(Common.ReadPoolDataReturnValue memory result) {\r\n        result.pool = pool;\r\n        Common.Contributor[] memory targets = contributors[result.pool.big.recordId];\r\n        Common.ContributorReturnValue[] memory data = new Common.ContributorReturnValue[](targets.length);\r\n        if(result.pool.big.unit > 0) {\r\n            for(uint i = 0; i < targets.length; i++) {\r\n                address target = targets[i].id;\r\n                data[i] = _getContributor(target, result.pool.big.unit);\r\n            }\r\n            result.cData = data;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev Get pool from storage\r\n     * @param unit : Unit contribution\r\n     */\r\n    function isPoolAvailable(uint256 unit) public view returns(bool) {\r\n        return _getPool(unit).status == Common.Status.AVAILABLE;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the profile of target\r\n     * @param unit : unit contribution\r\n     * @param target : User\r\n     */\r\n    function getProfile(\r\n        uint256 unit,\r\n        address target\r\n    )\r\n        external\r\n        view\r\n        // onlyInitialized(unit, false)\r\n        returns(Common.ContributorReturnValue memory) \r\n    {\r\n        return _getContributor(target, unit);\r\n    }\r\n\r\n    function _replaceContributor(address liquidator, uint96 recordId, Common.Slot memory slot, address _defaulter, uint unit) internal {\r\n        Common.Provider[] memory providers = unitProviders[recordId][_defaulter];\r\n        if(providers.length > 0) {\r\n            unitProviders[recordId][liquidator] = unitProviders[recordId][_defaulter];\r\n            delete unitProviders[recordId][_defaulter];\r\n        }\r\n        contributors[recordId][slot.value].id = liquidator;\r\n        _setSlot(liquidator, unit, slot, false);\r\n        _setSlot(_defaulter, unit, slot, true);\r\n        // _defaulter.id = liquidator;\r\n        // contributors[recordId][slot.value] = _defaulter;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns amount of collateral required in a pool.\r\n     * @param unit : EpochId\r\n     * @return collateral Collateral\r\n     * @return colCoverage Collateral coverage\r\n     */\r\n    function _getCollateralQuote(uint256 unit)\r\n        internal\r\n        view\r\n        returns(uint collateral, uint24 colCoverage)\r\n    {\r\n        Common.Pool memory pool = _getPool(unit);\r\n        if(pool.big.unit > 0) {\r\n            unchecked {\r\n                (collateral, colCoverage) = (Common.Price(\r\n                        _getCollateralTokenPrice(pool.addrs.colAsset), \r\n                        diaOracleAddress == address(0)? 18 : 8\r\n                    ).computeCollateral(\r\n                        uint24(pool.low.colCoverage), \r\n                        pool.big.unit * pool.low.maxQuorum\r\n                    ),\r\n                    uint24(pool.low.colCoverage)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the current debt of last paid acount i.e the contributor that last got finance\r\n     * @param unit : Unit contribution\r\n     * @notice For every contributor that provide liquidity through providers, they are required to \r\n     * pay interest in proportion to the providers' rate. Every other contributors in the same pool \r\n     * will pay interest to the same set of providers but the interest will be halved.\r\n     */\r\n    function _getCurrentDebt(uint unit) internal view returns (uint256 debt, Common.Pool memory pool) {\r\n        pool = _getPool(unit);\r\n        assert(pool.addrs.lastPaid != address(0));\r\n        Common.Contributor[] memory profiles = contributors[pool.big.recordId];\r\n        if(profiles.length > 0) {\r\n            for(uint i = 0; i < profiles.length; i++){\r\n                Common.ContributorReturnValue memory data = _getContributor(profiles[i].id, unit);\r\n                if(data.profile.id == pool.addrs.lastPaid) {\r\n                    debt += data.profile.loan;\r\n                }\r\n                if(data.providers.length > 0) {\r\n                    for(uint j = 0; j < data.providers.length; j++){\r\n                        unchecked { \r\n                            Common.Provider memory provider = data.providers[j];\r\n                            if(_now() > provider.earnStartDate) {\r\n                                if(data.profile.id == pool.addrs.lastPaid) debt += provider.accruals.intPerSec * (_now() - provider.earnStartDate);\r\n                                else debt += (provider.accruals.intPerSec / 2) * (_now() - provider.earnStartDate);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n      /**\r\n   * @dev Return struct object with data if current beneficiary has defaulted otherwise an empty struct is returned.\r\n   * @param unit: Unit contribution\r\n   */\r\n    function _enquireLiquidation(uint unit) \r\n        internal \r\n        view \r\n        returns (Common.Contributor memory _profile, bool isDefaulted, Common.Slot memory slot) \r\n    {\r\n        Common.Pool memory pool = _getPool(unit);\r\n        assert(pool.addrs.lastPaid != address(0));\r\n        Common.ContributorReturnValue memory _default = _getContributor(pool.addrs.lastPaid, unit);\r\n        if(_now() > _default.profile.paybackTime) {\r\n            assert(pool.addrs.lastPaid == _default.profile.id);\r\n            (_profile, isDefaulted, slot) = (_default.profile, true, _default.slot);\r\n        } \r\n    }\r\n\r\n    /**\r\n        * @dev Check liquidation opportunity in the pool\r\n        * @param unit : Unit contribution\r\n    */\r\n    function enquireLiquidation(uint unit) public view returns(Common.Contributor memory profile, bool defaulter, Common.Slot memory slot) {\r\n        return _enquireLiquidation(unit);\r\n    }\r\n\r\n    function _now() internal view returns(uint32 time) {\r\n        time = uint32(block.timestamp);\r\n    }\r\n    \r\n}"
    },
    "contracts/peripherals/Epoches.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { PastEpoches, Common, Counters } from \"./PastEpoches.sol\";\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\n\r\nabstract contract Epoches is PastEpoches {\r\n    using Counters for Counters.Counter;\r\n    using ErrorLib for *;\r\n\r\n    // Past/completed pools\r\n    Counters.Counter private epoches;\r\n\r\n    // Mapping of unitId to current Pool\r\n    mapping(uint96 => Common.Pool) private pools; \r\n\r\n    /**\r\n     * @dev Mapping of unit contribution to unitId\r\n     * For every unit amount of contribution, there is a corresponding index for retrieving data from the storage.\r\n     */\r\n    mapping(uint256 => uint96) private indexes; \r\n\r\n    /**\r\n     * @dev Verify that the contribution unit is not active. \r\n     * @notice When unit is not active, it can be relaunched. \r\n     */\r\n    modifier _onlyIfUnitIsNotActive(uint unit){\r\n        if(_isUnitActive(unit)) 'Unit is active'._throw();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Verify that the contribution unit is \r\n     */\r\n    modifier _onlyIfUnitIsActive(uint unit){\r\n        if(!_isUnitActive(unit)) 'Unit is inActive'._throw();\r\n        _;\r\n    }\r\n\r\n    /**\r\n        * @dev Ensure that unit contribution is active.\r\n        * Every unit contribution has a corresponding and unique id called unitId.\r\n        * When a unitId equals zero mean it is not active\r\n    */\r\n    function _isUnitActive(uint unit) internal view returns(bool result){\r\n        result = pools[_getUnitId(unit)].status == Common.Status.TAKEN;\r\n    }\r\n\r\n    function _getUnitId(uint unit) internal view returns(uint96 _unitId) {\r\n        _unitId = indexes[unit];\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev Return record Id in a pool with unit contribution\r\n     * @param unit : Unit contribution\r\n    */\r\n    function _getRecordId(uint unit) internal view returns(uint96 _recordId) {\r\n        _recordId = _getPool(unit).big.recordId;\r\n    }\r\n\r\n    // Generate unit Id and record Id\r\n    function _generateIds(uint unit) internal returns(uint96 unitId, uint96 recordId) {\r\n        epoches.increment();\r\n        unitId = uint96(epoches.current());\r\n        indexes[unit] = unitId;\r\n        recordId = _generateRecordId();\r\n    }\r\n\r\n    /**\r\n     * @dev Fetch current pool with unit contribution\r\n     * @param unit : Unit contribution\r\n     */\r\n    function _getPool(uint unit) internal view returns(Common.Pool memory result) {\r\n        result = _getPoolWithUnitId(_getUnitId(unit));\r\n    }\r\n\r\n    /**\r\n     * @dev Fetch Current pool with unitId\r\n     * @param unitId : Unit Id\r\n     */\r\n    function _getPoolWithUnitId(uint96 unitId) internal view returns(Common.Pool memory result){\r\n        result = pools[unitId];\r\n    }\r\n\r\n    // Return past pool counter\r\n    function _getEpoches() internal view returns(uint96 _epoches) {\r\n        _epoches = uint96(epoches.current());\r\n    }\r\n\r\n    /// @dev Update pool in storage \r\n    function _setPool(uint96 unitId, Common.Pool memory pool) internal {\r\n        pools[unitId] = pool;\r\n    }\r\n\r\n    /**\r\n     * @dev Shuffle pools i.e move the current pool to history and reset it \r\n     * @param pool : Current pool\r\n     */ \r\n    function _shufflePool(Common.Pool memory pool) internal {\r\n        Common.Pool memory empty = pools[0];\r\n        _setPool(pool.big.unitId, empty);\r\n        _setRecord(pool.big.recordId, pool);\r\n    }\r\n\r\n    /**@dev Check if pool is filled\r\n        * @dev Msg.sender must not be a member of the band at epoch Id before now.\r\n        * @param pool: Pool struct (Location: Memory)\r\n        * @notice : Be sure to wrap this function in an uncheck block\r\n    */\r\n    function _isPoolFilled(Common.Pool memory pool, bool isPermissioned) \r\n        internal \r\n        pure\r\n        returns(bool filled) \r\n    {\r\n        unchecked {\r\n            filled = !isPermissioned? pool.low.userCount == pool.low.maxQuorum : pool.big.currentPool == (pool.big.unit * pool.low.maxQuorum);\r\n        }\r\n    }\r\n\r\n    /**@dev Sets new last paid */\r\n    function _setLastPaid(address to, uint unit) internal {\r\n        pools[_getPool(unit).big.unitId].addrs.lastPaid = to;\r\n    }\r\n\r\n\r\n}"
    },
    "contracts/peripherals/ERC20Manager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport { IERC20 } from \"../apis/IERC20.sol\";\r\nimport { ISupportedAsset } from \"../apis/ISupportedAsset.sol\";\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\nimport { SafeGetter, IRoleBase, ISafeFactory } from \"./SafeGetter.sol\";\r\n\r\nabstract contract ERC20Manager is SafeGetter {\r\n    using ErrorLib for *;\r\n\r\n    // Supportasset manager contract\r\n    ISupportedAsset public immutable assetManager;\r\n\r\n    // Base asset contract e.g cUSD\r\n    IERC20 public immutable baseAsset;\r\n\r\n    modifier onlySupportedAsset(IERC20 asset) {\r\n        if(asset != baseAsset){\r\n            if(!ISupportedAsset(assetManager).isSupportedAsset(address(asset))) 'Unsupported Asset'._throw();\r\n        }\r\n        _;\r\n    }\r\n\r\n    // ============= Constructor ================\r\n\r\n    constructor(\r\n        ISupportedAsset _assetManager, \r\n        IERC20 _baseAsset, \r\n        IRoleBase _roleManager, \r\n        ISafeFactory _safeFactory\r\n    ) SafeGetter(_safeFactory, _roleManager) {\r\n        if(_assetManager == assetManager) \"_assetManager is zero\"._throw();\r\n        if(_baseAsset == baseAsset) \"_baseAsset is zero\"._throw();\r\n        assetManager = _assetManager;\r\n        baseAsset = _baseAsset;\r\n    }\r\n\r\n    /**\r\n     * @dev Validate allowance given by user against actual value\r\n     * @param asset : ERC20 compatible contract\r\n     * @param owner : Owner account\r\n     * @param value : Value to compare allowance to\r\n     */\r\n    function _validateAllowance(\r\n        IERC20 asset, \r\n        address owner, \r\n        uint value\r\n    ) \r\n        onlySupportedAsset(asset)\r\n        internal \r\n        view\r\n        returns(uint allowance) \r\n    {\r\n        assert(address(asset) != address(0));\r\n        assert(owner != address(0));\r\n        allowance = IERC20(asset).allowance(owner, address(this));\r\n        if(allowance < value) 'Value exceed allowance'._throw();\r\n    }\r\n\r\n    /**\r\n     * @dev Validate allowance given by user against actual value\r\n     * @param asset : ERC20 compatible contract\r\n     * @param owner : Owner account\r\n     * @param beneficiary : Recipient of the allowance\r\n     * @param value : Value to compare allowance to\r\n    */\r\n    function _checkAndWithdrawAllowance(IERC20 asset, address owner, address beneficiary, uint value) internal returns(uint allowance) {\r\n        allowance = _validateAllowance(asset, owner, value);\r\n        assert(beneficiary != address(0));\r\n        assert(address(asset) != address(0));\r\n        if(allowance > 0){\r\n            if(!IERC20(asset).transferFrom(owner, beneficiary, allowance)) 'TrxFer failed'._throw();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Approve an account to spend from the contract balance\r\n     * @param asset : ERC20 compatible contract\r\n     * @param spender : Recipient of the allowance\r\n     * @param value : Amount to approve\r\n    */\r\n    function _setApprovalFor(IERC20 asset, address spender, uint value) internal {\r\n        assert(spender != address(0));\r\n        assert(address(asset) != address(0));\r\n        if(!IERC20(asset).approve(spender, value)) 'Approval Failed'._throw();\r\n    }\r\n\r\n}"
    },
    "contracts/peripherals/FeeToAndRate.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\nimport { Utils } from \"../libraries/Utils.sol\";\r\nimport { Pool, IRoleBase, ISupportedAsset, IERC20, IPoint, ISafeFactory } from \"./Pool.sol\";\r\n\r\n/** \r\n * \r\n * @title FeeToAndRate\r\n * @author : Simplifi. Written by Isaac Jesse a.k.a Bobeu https://github.com/bobeu\r\n * @notice : Non-deployable contract for updating and retrieving the fee receiver account and the platform rate.\r\n * It should be implemented by the child contract.\r\n */\r\nabstract contract FeeToAndRate is Pool {\r\n    using ErrorLib for *;\r\n\r\n    // Fee recipient\r\n    address public feeTo;\r\n\r\n    // Platform fee (in %)\r\n    uint public makerRate;\r\n\r\n    /**\r\n     * =================== Constructor ===============\r\n     * @param _roleManager : Role manager contract\r\n     * @param _feeTo : Fee recipient\r\n     * @param _makerRate : Platform fee\r\n     * \r\n     */\r\n    constructor(\r\n        address _feeTo, \r\n        uint16 _makerRate,\r\n        address _diaOracleAddress, \r\n        IRoleBase _roleManager, \r\n        ISupportedAsset _assetManager, \r\n        IERC20 _baseAsset,\r\n        IPoint _pointFactory,\r\n        ISafeFactory _safeFactory\r\n    ) Pool(_diaOracleAddress, _assetManager, _roleManager, _baseAsset, _pointFactory, _safeFactory) {\r\n        if(_feeTo == feeTo) '_feeTo is empty'._throw();\r\n        if(_makerRate > Utils._getBase()) 'Invalid maker rate'._throw();\r\n        feeTo = _feeTo;\r\n        makerRate = _makerRate;\r\n    }\r\n\r\n    /**\r\n     * @dev Set fee or maker rate. The status of the value parsed determines which to update.\r\n     * @param _feeTo : Fee receiving account. \r\n     * @param _makerRate : Platform fee (in %)\r\n     * @notice : For detailed doc on setting maker rate, see Utils.sol._getPercentage()\r\n     */\r\n    function setFeeOrMakerRate(\r\n        address _feeTo,\r\n        uint16 _makerRate\r\n    ) public onlyRoleBearer returns(bool) {\r\n        if(_feeTo != feeTo && _feeTo != address(0)) feeTo = _feeTo;\r\n        if(_makerRate > 0 && _makerRate < Utils._getBase()) makerRate = _makerRate;\r\n        return true;\r\n    }\r\n    \r\n}"
    },
    "contracts/peripherals/MinimumLiquidity.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\nimport { ERC20Manager, IRoleBase, IERC20, ISupportedAsset, ISafeFactory } from \"./ERC20Manager.sol\";\r\n\r\nabstract contract MinimumLiquidity is ERC20Manager {\r\n    using ErrorLib for *;\r\n\r\n    // Minimum liquidity a provider can make\r\n    uint public minimumLiquidity;\r\n\r\n    // ============= Constructor ================\r\n    constructor(\r\n        ISupportedAsset _assetManager,\r\n        IERC20 _baseAsset, \r\n        IRoleBase _roleManager,\r\n        ISafeFactory _safeFactory\r\n    ) ERC20Manager(_assetManager, _baseAsset, _roleManager, _safeFactory){\r\n        if(address(_roleManager) == address(0)) '_roleManager is zero'._throw();\r\n    }\r\n\r\n    /**\r\n     * @dev Set minimum liquidity. \r\n     * @param _minLiquidity : Minimum liquidity\r\n     * @notice Only accounts with rolebearer access are allowed\r\n     */\r\n    function setMinimumLiquidity(uint _minLiquidity) public onlyRoleBearer {\r\n        if(_minLiquidity == minimumLiquidity) 'Param is same'._throw();\r\n        minimumLiquidity = _minLiquidity;\r\n    }\r\n}"
    },
    "contracts/peripherals/OnlyRoleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IRoleBase } from \"../apis/IRoleBase.sol\";\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\n\r\n/**\r\n * @title MsgSender \r\n * @author Simplifi (Bobeu)\r\n * @notice Non-deployable contract simply returning the calling account.\r\n */\r\nabstract contract MsgSender {\r\n    function _msgSender() internal view virtual returns(address sender) {\r\n        sender = msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract OnlyRoleBase is MsgSender {\r\n    using ErrorLib for *;\r\n\r\n    // Role manager address\r\n    IRoleBase public roleManager;\r\n\r\n    // ============= constructor ============\r\n    constructor(IRoleBase _roleManager)\r\n    {\r\n        _setRoleManager(_roleManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Caller must have owner role before execeution can proceed.\r\n     * The 'errorMessage' argument can be used to return error specific to \r\n     * a context e.g function call. \r\n     */\r\n    modifier onlyRoleBearer {\r\n        _onlyRoleBearer();\r\n        _;\r\n    }\r\n\r\n    // Allow only account with role access\r\n    function _onlyRoleBearer() internal view {\r\n        IRoleBase mgr = roleManager;\r\n        if(address(mgr) == address(0)) 'Manager is zero'._throw();\r\n        if(!_hasRole(_msgSender())) 'Access denied'._throw();\r\n    }\r\n\r\n    function _hasRole(address target) internal view returns(bool result) {\r\n        result = IRoleBase(roleManager).hasRole(target);\r\n    }  \r\n\r\n    /// @dev Set role manager\r\n    function _setRoleManager(IRoleBase newManager) private{\r\n        roleManager = newManager;\r\n    }\r\n\r\n    /**\r\n     * Set Role manager\r\n     * @param newManager : New manager address\r\n     */\r\n    function setRoleManager(\r\n        address newManager\r\n    )\r\n        public\r\n        onlyRoleBearer\r\n        returns(bool)\r\n    {\r\n        _setRoleManager(IRoleBase(newManager));\r\n        return true;\r\n    }\r\n}"
    },
    "contracts/peripherals/PastEpoches.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"../apis/Common.sol\";\r\nimport { Counters } from \"@thirdweb-dev/contracts/external-deps/openzeppelin/utils/Counters.sol\";\r\n\r\nabstract contract PastEpoches {\r\n    using Counters for Counters.Counter;\r\n\r\n    // Past/completed pools\r\n    Counters.Counter private pastEpoches;\r\n\r\n    // Mapping of recordIds to past pools\r\n    mapping(uint96 => Common.Pool) private records; \r\n\r\n    // Return past pool counter\r\n    function _getPastEpoches() internal view returns(uint96 recordId) {\r\n        recordId = uint96(pastEpoches.current()); \r\n    }\r\n\r\n    // Generate and return recordId\r\n    function _generateRecordId() internal returns(uint96 recordId) {\r\n        recordId = _getPastEpoches();\r\n        pastEpoches.increment();\r\n    }\r\n\r\n    /// @dev Add a completed pool to history \r\n    function _setRecord(uint96 recordId, Common.Pool memory pool) internal {\r\n        records[recordId] = pool;\r\n    }\r\n\r\n    /**\r\n     * @dev Return past pool at recordId \r\n     * @param recordId : Record Id\r\n     */\r\n    function _getPastPool(uint96 recordId) internal view returns(Common.Pool memory result) {\r\n        result = records[recordId];\r\n        return result;\r\n    }\r\n\r\n}"
    },
    "contracts/peripherals/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { OnlyRoleBase, IRoleBase } from \"./OnlyRoleBase.sol\";\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n * \r\n * We use part of the Openzeppelin Pausable contract to supplement our strategy.\r\n * Thanks to the OZ team.\r\n */\r\nabstract contract Pausable is OnlyRoleBase {\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is paused.\r\n     */\r\n    error EnforcedPause();\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is not paused.\r\n     */\r\n    error ExpectedPause();\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor(\r\n        IRoleBase _roleManager\r\n    ) OnlyRoleBase(_roleManager) {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view {\r\n        if (paused()) {\r\n            revert EnforcedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        if (!paused()) {\r\n            revert ExpectedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     * Only owner role can call.\r\n     * - The contract must not be paused.\r\n     */\r\n    function pause() \r\n        public \r\n        onlyRoleBearer\r\n        whenNotPaused \r\n    {\r\n        _paused = true; \r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     * - Only owner role can call.\r\n     * - The contract must be paused.\r\n     */\r\n    function unpause() \r\n        public \r\n        onlyRoleBearer \r\n        whenPaused \r\n    {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n"
    },
    "contracts/peripherals/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"hardhat/console.sol\";\r\nimport { \r\n    Contributor, \r\n    Common, \r\n    ErrorLib, \r\n    Utils, \r\n    IRoleBase, \r\n    IERC20, \r\n    IPoint, \r\n    ISupportedAsset,\r\n    ISafeFactory\r\n} from \"./Contributor.sol\";\r\nimport { ISafe } from \"../apis/ISafe.sol\";\r\n\r\nabstract contract Pool is Contributor {\r\n    using Utils for *;\r\n    using ErrorLib for *;\r\n\r\n    // ================ Constructor ==============\r\n    constructor(\r\n        address _diaOracleAddress, \r\n        ISupportedAsset _assetManager, \r\n        IRoleBase _roleManager,\r\n        IERC20 _baseAsset,\r\n        IPoint _pointFactory,\r\n        ISafeFactory _safeFactory\r\n    ) \r\n        Contributor(_diaOracleAddress, _assetManager, _roleManager, _baseAsset, _pointFactory, _safeFactory)\r\n    {}\r\n\r\n    /**\r\n     * @dev Create a pool internally\r\n     * @param users : Participants\r\n     * @param unit : Unit contribution\r\n     * @param maxQuorum : Maximum number of contributors that can participate\r\n     * @param durationInHours : Maximum duration in hours each borrower can retain the loan\r\n     * @param colCoverage : Ration of collateral coverage or index required as cover for loan\r\n     * @param router : Router : PERMISSIOLESS or PERMISSIONED\r\n     */\r\n    function _createPool(\r\n        address[] memory users,\r\n        address sender,\r\n        uint unit,\r\n        uint8 maxQuorum,\r\n        uint16 durationInHours,\r\n        uint24 colCoverage,\r\n        Common.Router router,\r\n        IERC20 colAsset\r\n    ) internal _onlyIfUnitIsNotActive(unit) onlySupportedAsset(colAsset) returns(Common.Pool memory pool) {\r\n        if(durationInHours == 0 || durationInHours > 720) 'Invalid duration'._throw();\r\n        if(router == Common.Router.PERMISSIONLESS){\r\n            if(users.length > 1 || users.length == 0) 'Expect 1 item in list'._throw();\r\n            assert(users[0] == sender);\r\n        } else {\r\n            if(users.length < 2) 'List too low for router2'._throw();\r\n            if(sender != users[0]) 'Sender not in list'._throw();\r\n        }\r\n        (uint96 unitId, uint96 recordId) = _generateIds(unit);\r\n        pool = _updatePool(Common.UpdatePoolData(unit, unitId, recordId, maxQuorum, colCoverage, colAsset, durationInHours, users[0], router));  \r\n        pool = _addUserToPool(unit, users, pool);\r\n        _setPool(unitId,  pool);\r\n        _completeAddUser(users[0] == _msgSender()? users[0] : _msgSender(), pool);\r\n    }\r\n\r\n    /**\r\n     * @dev Add users to newly created pool\r\n     * @param unit : Unit contribution\r\n     * @param users : List of contributors to add\r\n     * @param pool : Pool data. Must be an existing data relating to the unit contribution\r\n     */\r\n    function _addUserToPool(\r\n        uint256 unit, \r\n        address[] memory users,\r\n        Common.Pool memory pool\r\n    ) internal returns(Common.Pool memory _pool) {\r\n        for(uint i = 0; i < users.length; i++) {\r\n            Common.ContributorReturnValue memory data;\r\n            if(i == 0) data = _initializeContributor(pool, unit, users[i], true, true, true);\r\n            else {\r\n                if(users[0] == users[i]) 'Creator spotted twice'._throw();\r\n                data = _initializeContributor(pool, unit, users[i], false, true, false);\r\n            }\r\n            _setContributor(data.profile, pool.big.recordId, uint8(data.slot.value), false);\r\n        }\r\n        _pool = pool;\r\n    }\r\n\r\n    /**\r\n        * @dev Add user to existing pool\r\n        * @param unit : Unit contribution\r\n        * @param user : Contributors to add\r\n        * @param pool : Pool data. Must be an existing data relating to the unit contribution\r\n    */\r\n    function _joinAPool(\r\n        uint256 unit, \r\n        address user,\r\n        Common.Pool memory pool\r\n    ) internal _onlyIfUnitIsActive(unit) returns(Common.Pool memory _pool) {\r\n        if(pool.stage != Common.Stage.JOIN) 'Invalid stage'._throw();\r\n        Common.ContributorReturnValue memory data;\r\n        unchecked {\r\n            pool.big.currentPool += pool.big.unit;\r\n            pool.low.userCount += 1;\r\n        }\r\n        if(pool.router == Common.Router.PERMISSIONED) {\r\n            _onlyContributor(user, unit, false);\r\n            data = _getContributor(user, unit);\r\n            data.profile.sentQuota = true;\r\n        } else {\r\n            _onlyNonContributor(user, unit);\r\n            data = _initializeContributor(pool, unit, user, false, true, true);\r\n        }\r\n        _setContributor(data.profile, pool.big.recordId, uint8(data.slot.value), false);\r\n        if(_isPoolFilled(pool, pool.router == Common.Router.PERMISSIONED)) {\r\n            _setTurnStartTime(address(0), unit, _now());\r\n            pool.stage = Common.Stage.GET;\r\n        }\r\n        _pool = pool;\r\n        _completeAddUser(user, pool);\r\n    }\r\n    \r\n    /**\r\n        * @dev Complete the add task.\r\n        * @param user : Contributors to add\r\n        * @param pool : Pool data. Must be an existing data relating to the unit contribution\r\n    */\r\n    function _completeAddUser(address user, Common.Pool memory pool) internal {\r\n        _checkAndWithdrawAllowance(IERC20(baseAsset), user, pool.addrs.safe, pool.big.unit);\r\n        if(!ISafe(pool.addrs.safe).addUp(user, pool.big.recordId)) 'Add user failed'._throw();\r\n    }\r\n\r\n    /**\r\n     * @dev Update pool with relevant data\r\n     * @param data : Function argument of type Common.UpdatePoolData\r\n     */\r\n    function _updatePool(Common.UpdatePoolData memory data) internal returns(Common.Pool memory pool) {\r\n        unchecked {\r\n            pool.low = Common.Low(data.maxQuorum, 0, data.colCoverage, uint32(uint(data.durationInHours) * 1 hours), 0, 1);\r\n        }\r\n        pool.big = Common.Big(data.unit, data.unit, data.recordId, data.unitId);\r\n        pool.addrs = Common.Addresses(data.colAsset, address(0), _getSafe(data.unit), data.creator);\r\n        pool.router = data.router;\r\n        pool.status = Common.Status.TAKEN;\r\n        pool.stage = Common.Stage.JOIN;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns amount of collateral required in a pool.\r\n     * @param unit : EpochId\r\n     * @return collateral Collateral\r\n     * @return colCoverage Collateral coverage\r\n     */\r\n    function getCollateralQuote(uint256 unit) public view returns(uint collateral, uint24 colCoverage)\r\n    {\r\n       return _getCollateralQuote(unit);\r\n    }\r\n\r\n    /**\r\n     * Returns the current debt of target user.\r\n     * @param unit : Unit contribution\r\n     */\r\n    function getCurrentDebt(uint256 unit) public view returns(uint256 debt) \r\n    {\r\n       (debt,) = _getCurrentDebt(unit);\r\n       return debt;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/peripherals/Price.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IDIAOracleV2 } from \"../apis/IDIAOracleV2.sol\";\r\nimport { IERC20 } from \"../apis/IERC20.sol\";\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\nimport { ERC20Manager, IERC20, ISupportedAsset, IRoleBase, ISafeFactory } from \"./ERC20Manager.sol\";\r\n\r\nabstract contract Price is ERC20Manager {\r\n    using ErrorLib for *;\r\n\r\n    // DIA oracle address\r\n    address public immutable diaOracleAddress;\r\n\r\n    // Mapping of supported collateral asset to price pair\r\n    mapping (IERC20 tokenAddress => string) private pairs;\r\n\r\n    // ============= constructor ============\r\n    constructor(\r\n        address _diaOracleAddress, \r\n        ISupportedAsset _assetManager, \r\n        IRoleBase _roleManager,\r\n        IERC20 _baseAsset,\r\n        ISafeFactory _safeFactory\r\n    ) \r\n        ERC20Manager(_assetManager, _baseAsset, _roleManager, _safeFactory)\r\n    {\r\n        diaOracleAddress = _diaOracleAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Map collateral asset to their corresponding pair for price retrieval\r\n     * @param collateralAsset : ERC20 compatible asset\r\n     * @param pair : Price pair e.g cUSD/USDT\r\n     * @notice Collateral asset must be supported\r\n    */\r\n    function setPair(\r\n        IERC20 collateralAsset, \r\n        string memory pair\r\n    ) \r\n        public \r\n        onlyRoleBearer\r\n        onlySupportedAsset(collateralAsset)\r\n        returns(bool) \r\n    {\r\n        if(bytes(pair).length == 0) 'Invalid pair'._throw();\r\n        if(address(collateralAsset) == address(0)) 'Asset is zero'._throw();\r\n        pairs[collateralAsset] = pair;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Get price of collateral token.\r\n     * @notice For now, if DIAOracle address is empty, its on Celo network otherwise we use a \r\n     * dummy price pending when Price Oracle is full implemented on the Celo network\r\n     */\r\n    function _getCollateralTokenPrice(IERC20 colAsset) internal view returns (uint128 _price) {\r\n        string memory pair = pairs[colAsset];\r\n        if(diaOracleAddress != address(0)) {\r\n            (uint128 price,) = IDIAOracleV2(diaOracleAddress).getValue(pair); \r\n            _price = price;\r\n        } else {\r\n            _price = 10000000000000000000;\r\n        }\r\n    }\r\n}"
    },
    "contracts/peripherals/Safe.sol": {
      "content": "// SPDX-License-Identifier: MIT \r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { ReentrancyGuard } from \"@thirdweb-dev/contracts/external-deps/openzeppelin/security/ReentrancyGuard.sol\";\r\nimport { IERC20 } from \"../apis/IERC20.sol\";\r\nimport { IFactory } from \"../apis/IFactory.sol\";\r\nimport { ISafe } from \"../apis/ISafe.sol\";\r\nimport { Common } from \"../apis/Common.sol\";\r\nimport { OnlyRoleBase, IRoleBase } from \"../peripherals/OnlyRoleBase.sol\";\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\n\r\ncontract Safe is ISafe, OnlyRoleBase, ReentrancyGuard {\r\n    using ErrorLib for *;\r\n\r\n    // Number of contributors currently operating this safe\r\n    uint private userCount;\r\n\r\n    // Total fee collected\r\n    uint private aggregateFee;\r\n\r\n    // Amount to date paid by contributors\r\n    uint256 public totalAmountIn;\r\n\r\n    // Fee Receiver\r\n    address public immutable feeTo;\r\n\r\n    // Mapping of user to record Id to access\r\n    mapping(address => mapping(uint => bool)) private access;\r\n\r\n    // Mapping of users to recordId to Collateral\r\n    mapping(address => mapping(uint => uint256)) private collateralBalances;\r\n\r\n    // Mapping of contributors to amount paid as debt serviced\r\n    mapping(address contributor => uint) public paybacks;\r\n\r\n    ///@dev Only users with access role are allowed\r\n    modifier hasAccess(address user, uint recordId) {\r\n        if (!access[user][recordId]) 'User does not have access'._throw();\r\n        _;\r\n    }\r\n\r\n    /** ========== Constructor ===============\r\n     * @param _roleManager : RoleBase manager contract\r\n     * @param _feeTo : Fee receiver account\r\n     */\r\n    constructor(IRoleBase _roleManager, address _feeTo) OnlyRoleBase(_roleManager) {\r\n        feeTo = _feeTo;\r\n    }\r\n\r\n    receive() external payable {\r\n        (bool s, ) = feeTo.call{value: msg.value}(\"\");\r\n        require(s);\r\n    }\r\n\r\n    /**\r\n     * @dev Registers new user\r\n     * @param user New user\r\n\r\n    */\r\n    function _addUser(address user, uint recordId) private {\r\n        assert(!access[user][recordId]);\r\n        access[user][recordId] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Implementation of ISafe.addUp\r\n     * See ISafe.addUp\r\n     */\r\n    function addUp(address user, uint recordId) external onlyRoleBearer returns (bool) {\r\n        unchecked {\r\n            userCount++;\r\n        }\r\n        _addUser(user, recordId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev UnLocks collateral balances\r\n     * @param user Existing user\r\n\r\n    */\r\n    function _removeUser(address user, uint recordId) private {\r\n        assert(access[user][recordId]);\r\n        if(userCount > 0) {\r\n            unchecked {\r\n                userCount--;\r\n            }\r\n        }\r\n        access[user][recordId] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve spender contributor 'to' to spend from contract's balance\r\n     * @param to : Contributor\r\n     * @param asset : Currency in use\r\n     * @param amount : Value\r\n     * @notice Consideration is given to the previous allowances given to users.\r\n     */\r\n    function _setAllowance(address to, IERC20 asset, uint256 amount) private {\r\n        uint prev = IERC20(asset).allowance(address(this), to);\r\n        unchecked {\r\n            IERC20(asset).approve(to, amount + prev);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev End the current epoch\r\n     * @param baseAsset : AssetBase\r\n     * @param data : Contributors data\r\n     * @param unit : Unit contribution\r\n     */\r\n    function _tryRoundUp(\r\n        IERC20 baseAsset,\r\n        uint unit,\r\n        uint96 recordId,\r\n        Common.Contributor[] memory data\r\n    ) internal {\r\n        uint erc20Balances = IERC20(baseAsset).balanceOf(address(this));\r\n        uint fees = aggregateFee;\r\n        unchecked {\r\n            if(erc20Balances > 0) {\r\n                if(fees > 0 && erc20Balances > fees) {\r\n                    erc20Balances -= fees;\r\n                    aggregateFee = 0;\r\n                    if(!IERC20(baseAsset).transfer(feeTo, fees)) 'Fee transfer failed'._throw();\r\n                }\r\n                if(erc20Balances > 0) {\r\n                    for(uint i = 0; i < data.length; i++) {\r\n                        erc20Balances -= _settleAccruals(data[i], unit, recordId, baseAsset);\r\n                    }\r\n                    if(erc20Balances > 0) {\r\n                        if(!IERC20(baseAsset).transfer(feeTo, erc20Balances)) 'Fee2 transfer failed'._throw();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        userCount = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Get Finance - We send USD to user and accept collateral.\r\n     * @param user : Beneficiary.\r\n     * @param baseAsset : Asset base\r\n     * @param loan : Amount to receive as loan.\r\n     * @param fee : Amount charged as platform fee\r\n     * @param calculatedCol : Amount required to pay as collateral\r\n     * @param recordId : Record Id\r\n     */\r\n    function getFinance(\r\n        address user,\r\n        IERC20 baseAsset,\r\n        uint256 loan,\r\n        uint fee,\r\n        uint256 calculatedCol,\r\n        uint recordId\r\n    ) external hasAccess(user, recordId) onlyRoleBearer returns(bool) {\r\n        assert(address(baseAsset) != address(0) && user != address(0));\r\n        collateralBalances[user][recordId] = calculatedCol;\r\n        uint loanable = loan;\r\n        if (fee > 0) {\r\n            unchecked {\r\n                aggregateFee += fee;\r\n                if (loanable > fee) {\r\n                    loanable -= fee;\r\n                }\r\n            }\r\n        }\r\n        _setAllowance(user, baseAsset, loanable);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Pays back loan\r\n     * @param _p : Parameters of type PaybackParam\r\n     * _p.user : Current txn.origin not msg.sender\r\n     * _p.baseAsset : Asset base\r\n     * _p.debt : Amount owing by user\r\n     * _p.attestedInitialBal : Initial recorded balance of this contract before asset was transfered from the user.\r\n     * _p.allGF : Whether all the contributors have get finance or not\r\n     * _p.cData : Contributors data\r\n     * _p.isSwapped : If isSwapped is true, meaning the actual contributor defaulted.\r\n     * _p.defaulted : Address of the defaulted\r\n     * _p.collaterAsset: Asset used as collateral\r\n     * _p.recordId : Record Id. Every pool has a record Id i.e pool.bigInt.recordId\r\n     */\r\n    function payback(Common.Payback_Safe memory _p, uint unit) \r\n        external \r\n        onlyRoleBearer \r\n        hasAccess(_p.isSwapped? _p.defaulted : _p.user, _p.recordId) \r\n        returns (uint col) \r\n    {\r\n        col = collateralBalances[_p.user][_p.recordId];\r\n        if (_p.isSwapped) {\r\n            col = collateralBalances[_p.defaulted][_p.recordId];\r\n            collateralBalances[_p.defaulted][_p.recordId] = 0;\r\n            _removeUser(_p.defaulted, _p.recordId);\r\n        } else {\r\n            _removeUser(_p.user, _p.recordId);\r\n        }\r\n        collateralBalances[_p.user][_p.recordId] = 0;\r\n        paybacks[_p.user] = _p.debt;\r\n        unchecked {\r\n            totalAmountIn += _p.debt;\r\n        }\r\n        assert(IERC20(_p.baseAsset).balanceOf(address(this)) >= (_p.attestedInitialBal + _p.debt));\r\n        _setAllowance(_p.user, _p.collateralAsset, col);\r\n        if(_p.allGF) _tryRoundUp(_p.baseAsset, unit, _p.recordId, _p.cData);\r\n        return col;\r\n    }\r\n\r\n    /**\r\n     * @dev Settles all pending loans and interests due to providers provided the contributor \r\n     *      joined via providers' services.\r\n     * @notice The amount paid back by the contributor should be enough to settle the providers.\r\n     * @param data : Profile of the current contributor.\r\n     * @param unit : Unit contribution\r\n     * @param baseAsset : Asset used as contribution currency\r\n     */\r\n    function _settleAccruals(\r\n        Common.Contributor memory data, \r\n        uint unit, \r\n        uint96 recordId,\r\n        IERC20 baseAsset\r\n    ) internal returns(uint totalPaidOut) {\r\n        uint amtLeft = paybacks[data.id];\r\n        Common.Provider[] memory providers = IFactory(_msgSender()).getContributorProviders(data.id, recordId);\r\n        unchecked {\r\n            if(providers.length > 0) {\r\n                for(uint i = 0; i < providers.length; i++) {\r\n                    uint providerPay = providers[i].amount + (providers[i].accruals.intPerSec * (data.paybackTime - providers[i].earnStartDate));\r\n                    assert(amtLeft >= providerPay);\r\n                    amtLeft -= providerPay;\r\n                    _setAllowance(providers[i].account, baseAsset, providerPay);\r\n                }\r\n                totalPaidOut += amtLeft;\r\n            } else {\r\n                totalPaidOut += unit;\r\n                _setAllowance(data.id, baseAsset, unit);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called when a contributor remove a pool\r\n     * @param user : Contributor\r\n     * @param baseAsset : Asset base\r\n     * @param unit : Unit contribution\r\n     * @param recordId : Record Id\r\n     */\r\n    function cancel(\r\n        address user,\r\n        IERC20 baseAsset,\r\n        uint unit,\r\n        uint recordId\r\n    ) external onlyRoleBearer hasAccess(user, recordId) returns (bool) {\r\n        _setAllowance(user, baseAsset, unit);\r\n        _removeUser(user, recordId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Safe-related data\r\n     */\r\n    function getData() external view returns (ViewData memory) {\r\n        return ViewData(userCount, aggregateFee);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns User-related data\r\n     * @param user : Contributor\r\n     * @param recordId : Record Id\r\n     */\r\n    function getUserData(\r\n        address user,\r\n        uint recordId\r\n    ) external view returns (ViewUserData memory) {\r\n        return ViewUserData(access[user][recordId], collateralBalances[user][recordId]);\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/peripherals/SafeGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"../apis/Common.sol\";\r\nimport { ISafeFactory } from \"../apis/ISafeFactory.sol\";\r\nimport { Pausable, IRoleBase } from \"./Pausable.sol\";\r\n\r\n/**\r\n * @title : Safe storage contract\r\n * @author : Simplifi. Written by Isaac Jesse, a.k.a Bobeu https://github.com/bobeu\r\n * @notice : Safe is non-deployeable consumed by the FlexpoolFactory contract for managing contributors funds.\r\n *          We employed this strategy to achieve high security and users confidence while interacting with the protocol.\r\n *          The strategy utilizes the SafeGlobal protocol on the frontend to deploy a new Safe account for every unique \r\n *          contribution unit.\r\n */\r\nabstract contract SafeGetter is Pausable {\r\n\r\n    // Safe factory contract\r\n    ISafeFactory public immutable safeFactory;\r\n\r\n    // Mapping of unit contribution to Safe struct\r\n    mapping (uint256 => address) private safes;\r\n\r\n    constructor(ISafeFactory _safeFactory, IRoleBase _roleManager) Pausable(_roleManager) {\r\n        safeFactory = _safeFactory;\r\n    }\r\n\r\n    /**\r\n        * @dev Checks, validate and return safe for the target address.\r\n        * @param unit : Unit contribution.\r\n    */\r\n    function _getSafe(uint256 unit) internal returns(address safe) {\r\n        safe = ISafeFactory(safeFactory).pingSafe(unit);\r\n        assert(safe != address(0));\r\n    }\r\n}"
    },
    "contracts/peripherals/Slots.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"../apis/Common.sol\";\r\n\r\nabstract contract Slots {\r\n    // Every contributor owns a slot in each unit contribution\r\n    mapping(address contributor => mapping(uint256 unitContribution => Common.Slot)) slots;\r\n\r\n    /**\r\n        * @dev Create a new slot for target account\r\n        * @param target : Target account\r\n        * @param unit : Unit contribution\r\n        * @param position : User's position in the list of contributors\r\n        * @param isAdmin : Whether target is an admin or not\r\n        * @param isMember : Whether target is a member or not\r\n     */\r\n    function _createSlot(\r\n        address target, \r\n        uint unit,\r\n        uint8 position,\r\n        bool isAdmin,\r\n        bool isMember\r\n    ) internal {\r\n        _setSlot(\r\n            target,\r\n            unit, \r\n            Common.Slot(position, isMember, isAdmin),\r\n            false\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Set a new slot for the target\r\n     * @param target : Target account\r\n     * @param unit : unit contribution\r\n     * @param slot : Slot\r\n     */\r\n    function _setSlot( address target, uint unit, Common.Slot memory slot, bool setEmpty) internal {\r\n        Common.Slot memory empty;\r\n        slots[target][unit] = setEmpty? empty : slot;\r\n    }\r\n\r\n    /**\r\n        * @dev Returns the slot for target account\r\n        * @param target : Target account\r\n        * @param unit : Unit contribution\r\n    */\r\n    function _getSlot(\r\n        address target, \r\n        uint unit\r\n    ) internal view returns(Common.Slot memory slot) {\r\n        slot = slots[target][unit];\r\n    }\r\n\r\n    // For detailed doc, see _getSlot\r\n    function getSlot(address target, uint unit) \r\n        external \r\n        view \r\n        // onlyInitialized(unit, false)\r\n        returns(Common.Slot memory) \r\n    {\r\n        return _getSlot(target, unit);\r\n    }\r\n}"
    },
    "contracts/standalone/celo/FlexpoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport { FeeToAndRate, IRoleBase, ErrorLib, Utils, ISupportedAsset, ISafeFactory } from \"../../peripherals/FeeToAndRate.sol\";\r\nimport { IFactory, Common } from '../../apis/IFactory.sol';\r\nimport { IERC20 } from \"../../apis/IERC20.sol\";\r\nimport { IPoint } from \"../../apis/IPoint.sol\";\r\nimport { ISafe } from \"../../apis/ISafe.sol\";\r\n\r\n/**\r\n    * @title FlexpoolFactory\r\n    * @author Simplifi (Bobeu)\r\n    * @notice Deployable FlexpoolFactory contract that enables peer-funding. Participants of each pool are referred to \r\n    * contributors. There is no limit to the amount that can be contributed except for zer0 value. Users can single-handedly run\r\n    * a pool (where anyone is free to participate) or collectively with friends and family or peer operate a permissioned pool \r\n    * where participation is restricted to the preset members only.\r\n    * Users can use providers strategy to finance their quota if they can't afford the unit contribution. They can select multiple\r\n    * providers if the provider balance cannot the amount they wish to borrow. If this is the case, the selected providers are \r\n    * entitled to earn interest on the amount they provide.\r\n    * When paying back, the contributor will repay the full loan with interest but halved for other contributors.  \r\n*/\r\ncontract FlexpoolFactory is IFactory, FeeToAndRate {\r\n    using Utils for uint;\r\n    using ErrorLib for *;\r\n\r\n    // Analytics\r\n    Common.Analytics public analytics;\r\n\r\n    /** \r\n     * ================ Constructor ==============\r\n     * @param _roleManager : Role manager contract\r\n     * @param _pointFactory : Point Factory contract\r\n     * @param _assetManager : Asset manager contract\r\n     * @param _baseAsset : ERC20 compatible asset to use as base contribution\r\n     * @param _feeTo: Fee receiver\r\n     * @param _pointFactory : Platform fee\r\n    */\r\n    constructor(\r\n        address _feeTo, \r\n        uint16 _makerRate,\r\n        address _diaOracleAddress, \r\n        IRoleBase _roleManager, \r\n        ISupportedAsset _assetManager, \r\n        IERC20 _baseAsset,\r\n        IPoint _pointFactory,\r\n        ISafeFactory _safeFactory\r\n    ) \r\n        FeeToAndRate(_feeTo, _makerRate, _diaOracleAddress, _roleManager, _assetManager, _baseAsset, _pointFactory, _safeFactory)\r\n    {}\r\n\r\n    /**\r\n        * @dev Create a pool internally\r\n        * @param users : List of participating accounts\r\n        * @param unit : Unit contribution\r\n        * @param maxQuorum : Maximum number of contributors that can participate\r\n        * @param durationInHours : Maximum duration in hours each borrower can retain the loan\r\n        * @param colCoverage : Ration of collateral coverage or index required as cover for loan\r\n        * @param isPermissionless : Whether to create a permissionless or permissioned pool.\r\n        * @param colAsset : An ERC20-compatible asset to use as collateral currency \r\n        * @notice users list should be a list of participating accounts if it is permissioned including the\r\n        * creator being the first on the list. But the list can be empty if it is permissionless.\r\n    */\r\n    function createPool( \r\n        address[] calldata users,\r\n        uint unit,\r\n        uint8 maxQuorum,\r\n        uint16 durationInHours,\r\n        uint24 colCoverage,\r\n        bool isPermissionless,\r\n        IERC20 colAsset\r\n    ) public whenNotPaused returns(bool) {\r\n        Common.Pool memory pool = _createPool(users, _msgSender(), unit, maxQuorum, durationInHours, colCoverage, isPermissionless? Common.Router.PERMISSIONLESS : Common.Router.PERMISSIONED, colAsset);\r\n        _awardPoint(users[0], 0, 5, false);\r\n        _recordAnalytics(unit, 0, Common.Stage.JOIN, isPermissionless);\r\n        emit Common.PoolCreated(pool);\r\n      \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev launch a default permissionless pool\r\n     * @param user : Target user\r\n     * @param unit : Unit contribution\r\n     * @param initialPool : An Initialized pool. Can be an empty pool\r\n     */\r\n    function _launchDefault(address user, uint unit, Common.Pool memory initialPool) internal {\r\n        address[] memory users = new address[](1);\r\n        users[0] = user;\r\n        IERC20 defaultColAsset = IERC20(ISupportedAsset(assetManager).getDefaultSupportedCollateralAsset());\r\n        initialPool = _createPool(users, user, unit, 2, 72, 120, Common.Router.PERMISSIONLESS, defaultColAsset);\r\n        _awardPoint(users[0], 0, 5, false);\r\n        emit Common.PoolCreated(initialPool);\r\n    }\r\n\r\n    /**\r\n     * @dev Contributors can join a pool through a provider is they wish to borrow to finance the unit contribution.\r\n     *      If the unit is not taken, we add them to the pool otherwise a new pool will be launched.\r\n     * @param providers : List of providers that lend to the borrower\r\n     * @param borrower : Account address of the borrower\r\n     * @param unit : Amount borrowed will automatically be the unit contribution\r\n     * @notice By default, maxQuorum is set to 2 using this method. Users can immediately change the quorum\r\n     * to desired value otherwise it will not be possible if another contributor joins to complete the quorum.\r\n     * - durationInHrs is set to 72 hours by default.\r\n     * - colCoverage is set to 120 by default.\r\n     * Only accounts with the roleBearer are allowed i.e Ex. Providers contract\r\n     * If an user is contributing via the provider, we ensure the privacy of permissioned group is preserved.\r\n     */\r\n    function contributeThroughProvider(\r\n        Common.Provider[] memory providers, \r\n        address borrower, \r\n        uint unit\r\n    ) external onlyRoleBearer whenNotPaused returns(bool)\r\n    {\r\n        Common.Pool memory pool;\r\n        if(!isPoolAvailable(unit)){\r\n            pool = _getPool(unit);\r\n            if(pool.router == Common.Router.PERMISSIONED){\r\n                if(_getSlot(borrower, unit).isMember && !_getContributor(borrower, unit).profile.sentQuota){\r\n                    pool = _joinAPool(unit, borrower, pool);\r\n                    _setPool(pool.big.unitId, pool);\r\n                    emit Common.NewContributorAdded(pool);\r\n                } else 'User not permitted'._throw();\r\n            } else {\r\n                if(!_getSlot(borrower, unit).isMember && !_getContributor(borrower, unit).profile.sentQuota){\r\n                    pool = _joinAPool(unit, borrower, pool);\r\n                    _setPool(pool.big.unitId, pool);\r\n                    emit Common.NewContributorAdded(pool);\r\n                } else 'User not permitted'._throw();\r\n            }\r\n        } else {\r\n            _launchDefault(borrower, unit, pool);\r\n        }\r\n        _setProviders(providers, borrower, pool.big.recordId);\r\n        _recordAnalytics(unit, 0, Common.Stage.JOIN, true);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a contributor to a poool\r\n     * @param : Unit contribution\r\n     */\r\n    function contribute(uint unit) public whenNotPaused returns(bool) {\r\n        Common.Pool memory pool = _getPool(unit);\r\n        pool = _joinAPool(unit, _msgSender(), pool);\r\n        _setPool(pool.big.unitId, pool);\r\n        _recordAnalytics(unit, 0, Common.Stage.JOIN, pool.router == Common.Router.PERMISSIONLESS);\r\n        emit Common.NewContributorAdded(pool);\r\n\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Edit pool information\r\n     * @param unit : Unit contribution\r\n     * @param maxQuorum : Number of expected participants\r\n     * @param durationInHours : Number of time in hours each contributor can retain the loan\r\n     * @param colCoverage : Collateral coverage or ratio.\r\n     */\r\n    function editPool(\r\n        uint256 unit,\r\n        uint8 maxQuorum,\r\n        uint16 durationInHours,\r\n        uint24 colCoverage\r\n    ) \r\n        public \r\n        _onlyIfUnitIsActive(unit)\r\n        whenNotPaused\r\n        returns(bool) \r\n    {\r\n        Common.Pool memory pool = _getPool(unit);\r\n        uint32 duration;\r\n        if(_msgSender() != pool.addrs.admin) 'Not Allowed'._throw();\r\n        unchecked {\r\n            duration = durationInHours * 1 hours;\r\n        }\r\n        if(maxQuorum > pool.low.maxQuorum && maxQuorum < type(uint8).max) pool.low.maxQuorum = maxQuorum;\r\n        if(durationInHours <= 720 && duration > pool.low.duration) pool.low.duration = duration;\r\n        if(colCoverage > pool.low.colCoverage) pool.low.colCoverage = colCoverage;\r\n        _setPool(pool.big.unitId, pool);\r\n\r\n        emit Common.PoolEdited(pool);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Get finance\r\n     * @param unit : Unit contribution\r\n     * @return bool : Success or Failure\r\n     * @notice : To get finance, the unit contribution must be active. In the event the expected contributor failed to \r\n     * call, we swap their profile for the current msg.sender provided the grace period of 1hr has passed.\r\n    */\r\n    function getFinance(uint256 unit) public _onlyIfUnitIsActive(unit) whenNotPaused returns(bool) {\r\n        _onlyContributor(_msgSender(), unit, false);\r\n        (uint collateral,) = _getCollateralQuote(unit);\r\n        Common.Pool memory pool = _getPool(unit);\r\n        Common.Contributor memory profile = _getExpected(unit, pool.low.selector);\r\n        if(pool.stage != Common.Stage.GET) 'Borrow not ready'._throw();\r\n        if(pool.low.allGh == pool.low.maxQuorum) 'Epoch ended'._throw();\r\n        unchecked {\r\n            if(pool.big.currentPool < (pool.big.unit * pool.low.maxQuorum)) 'Pool fund incomplete'._throw();\r\n            if(_now() > profile.turnStartTime + 1 hours){\r\n                if(_msgSender() != profile.id) {\r\n                    profile = _swapContributors(unit, _msgSender(), _getSlot(_msgSender(), unit), profile);\r\n                }\r\n            } else {\r\n                if(_msgSender() != profile.id) 'TurnTime has not pass'._throw();\r\n            }\r\n            pool.low.allGh += 1;\r\n        }\r\n        pool.addrs.lastPaid = profile.id;\r\n        _recordAnalytics(pool.big.currentPool, collateral, Common.Stage.GET, pool.router == Common.Router.PERMISSIONLESS);\r\n        _checkAndWithdrawAllowance(IERC20(pool.addrs.colAsset), profile.id, pool.addrs.safe, collateral);\r\n        if(!ISafe(pool.addrs.safe).getFinance(profile.id, baseAsset, pool.big.currentPool, pool.big.currentPool.computeFee(uint16(makerRate)), collateral, pool.big.recordId)) 'Safe call failed'._throw();\r\n        (pool, profile) = _completeGetFinance(pool, collateral, profile);\r\n        _setContributor(profile, pool.big.recordId, uint8(_getSlot(pool.addrs.lastPaid, pool.big.unit).value), false);\r\n        _setPool(pool.big.unitId, pool);\r\n\r\n        emit Common.GetFinanced(pool);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Payback. For detailed documentation, see _payback\r\n     * @param unit : Unit contribution\r\n     */\r\n    function payback(uint unit) public whenNotPaused returns(bool) {\r\n        (Common.Pool memory pool, uint debt, uint collateral) = _payback(unit, _msgSender(), false, address(0));\r\n        _recordAnalytics(debt, collateral, Common.Stage.PAYBACK, pool.router == Common.Router.PERMISSIONLESS);\r\n        emit Common.Payback(pool);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @dev Liquidates a borrower if they have defaulted in repaying their loan.\r\n        - If the current beneficiary defaults, they're liquidated.\r\n        - Their collateral balances is forwarded to the liquidator. Liquidator also takes the full \r\n            responsibilities of the providers if any.\r\n        - Liquidator must not be a participant in pool at `unitId. We use this \r\n            to avoid fatal error in storage.\r\n        @param unit : Unit contribution.\r\n    */\r\n    function liquidate(uint256 unit) public whenNotPaused returns(bool) {\r\n        (Common.Contributor memory _defaulter, bool isDefaulted, Common.Slot memory slot) = _enquireLiquidation(unit);\r\n        if(!isDefaulted) 'Not defaulted'._throw();\r\n        address liquidator = _msgSender() ;\r\n        _onlyNonContributor(liquidator, unit);\r\n        _replaceContributor(liquidator, _getPool(unit).big.recordId, slot, _defaulter.id, unit);\r\n        assert(liquidator != _defaulter.id);\r\n        _setLastPaid(liquidator, unit); \r\n        (Common.Pool memory pool, uint debt, uint collateral) = _payback(unit, liquidator, true, _defaulter.id);\r\n        _recordAnalytics(debt, collateral, Common.Stage.PAYBACK, pool.router == Common.Router.PERMISSIONLESS);\r\n        emit Common.Payback(pool);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @dev Cancels a pool. Only pool with one contributor can be close.\r\n        @param unit : Unit contribution.\r\n        @notice : Only the creator of a pool can close it provided the number of contributors does not exceed one.\r\n    */\r\n    function closePool(uint256 unit) public whenNotPaused _onlyIfUnitIsActive(unit) returns(bool){\r\n        Common.Pool memory pool = _getPool(unit);\r\n        address creator = _msgSender();\r\n        if(creator != pool.addrs.admin) 'Only Admin can close pool'._throw();\r\n        bool isPermissionLess = pool.router == Common.Router.PERMISSIONLESS;\r\n        if(isPermissionLess) {\r\n            if(pool.low.userCount > 1) 'Cancellation disabled'._throw();\r\n        } else {\r\n            if(pool.big.currentPool > pool.big.unit) 'Cancellation disabled'._throw();\r\n        }\r\n        _awardPoint(creator, 0, 5, true);\r\n        pool.stage = Common.Stage.CANCELED;\r\n        _shufflePool(pool);\r\n        _recordAnalytics(pool.big.unit, 0, Common.Stage.CANCELED, isPermissionLess);\r\n        if(!ISafe(pool.addrs.safe).cancel(creator, baseAsset, pool.big.unit, pool.big.recordId)) 'Safe call failed'._throw();\r\n\r\n        emit Common.Cancellation(unit);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        * @dev Return providers associated with the target account\r\n        * @param target : Target account\r\n        * @param recordId : Record id\r\n    */\r\n    function getContributorProviders(address target, uint96 recordId) external view returns(Common.Provider[] memory result){\r\n        return  _getContributorProviders(target, recordId);\r\n    }\r\n    \r\n    /**\r\n     * @dev Record snapshot balances of base asset and collateral asset at any point in time\r\n     * @param baseValue : Value of baseAsset e.g Amount of cUSD contributed\r\n     * @param collateral : Collateral value going out or coming in.\r\n     * @param flag : For determining the type of operation to perform.\r\n     * @param isPermissionless : Whether the pool is permissioned or permissionless \r\n     */\r\n    function _recordAnalytics(uint baseValue, uint collateral, Common.Stage flag, bool isPermissionless) internal {\r\n        Analytics memory alt = analytics;\r\n        unchecked { \r\n            if(flag == Common.Stage.JOIN) {\r\n                alt.tvlBase += baseValue;\r\n                isPermissionless? alt.totalPermissionless += 1 : alt.totalPermissioned += 1;\r\n            } else if(flag == Common.Stage.GET) {\r\n                if(alt.tvlBase >= baseValue) alt.tvlBase -= baseValue;\r\n                alt.tvlCollateral += collateral;\r\n            } else if(flag == Common.Stage.PAYBACK) {\r\n                if(alt.tvlCollateral >= collateral) alt.tvlCollateral -= collateral;\r\n                alt.tvlBase += baseValue;\r\n            } else {\r\n                // otherwise, it will be canceled pool\r\n                if(alt.tvlBase >= baseValue) alt.tvlBase -= baseValue;\r\n            }\r\n        }\r\n        analytics = alt;\r\n    }\r\n\r\n    /**@dev Return contract data */\r\n    function getFactoryData() public view returns(Common.ViewFactoryData memory data) {\r\n        data.analytics = analytics;\r\n        data.makerRate = uint16(makerRate);\r\n        data.currentEpoches = _getEpoches();\r\n        data.recordEpoches = _getPastEpoches();\r\n        return data;\r\n    } \r\n\r\n}\r\n"
    },
    "contracts/standalone/celo/Providers.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport { IFactory, Common } from \"../../apis/IFactory.sol\";\r\nimport { MinimumLiquidity, IRoleBase, ErrorLib, IERC20, ISupportedAsset, ISafeFactory } from \"../../peripherals/MinimumLiquidity.sol\";\r\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\n/**\r\n * @title Providers\r\n * @author Simplifi (Bobeu)\r\n * @notice Deployable Providers contract is a general liquidity pool purposely for funding Flexpools.\r\n * Contributors that cannot afford unit contributions can access providers pool to source for funds. \r\n * Loans accessed in this pool are not withdrawable by the borrower. Since there is a direct relationship\r\n * between the Providers contract and the Flexpool's, borrowed funds are moved straight to the Flexpool contract\r\n * and registered on behalf of the contributor.\r\n * With this contract, you can perform the following actions:\r\n * - Provider liquidity.\r\n * - Remove liquidity\r\n * - Borrow to finance Flexpool\r\n * - Get the list of providers\r\n */\r\ncontract Providers is MinimumLiquidity, ReentrancyGuard {\r\n    using ErrorLib for *;\r\n    event LiquidityProvided(Common.Provider);\r\n    event LiquidityRemoved(Common.Provider);\r\n    event Borrowed(Common.Provider[] providers, address borrower);\r\n\r\n    struct Data { \r\n        uint id;\r\n        bool hasIndex;\r\n    }\r\n\r\n    // Flexpool factory contract\r\n    IFactory public immutable flexpoolFactory;\r\n\r\n    // List of providers\r\n    Common.Provider[] private providers;\r\n\r\n    /**\r\n     * @dev Mapping of providers to their position in the providers list\r\n     * @notice Slot '0' is reserved\r\n     */\r\n    mapping (address provider => Data) public slots;\r\n\r\n    /**\r\n     * ============= Constructor ================\r\n     * @param _roleManager : RoleBase manager contract.\r\n     * @param _baseAsset : Base asset to use for contribution e.g cUSD.\r\n     * @param _assetManager : Asset Manager contract.\r\n     * @notice At construction, we initialized the providers array slot 0 with an empty provider data.\r\n     * This is so we can reuse the slot in the future such as reseting a provider's data or ensuring \r\n     * that providers with zero index are restricted from calling certain functions.\r\n     */\r\n    constructor(\r\n        IFactory _flexpoolFactory,\r\n        IRoleBase _roleManager, \r\n        IERC20 _baseAsset,\r\n        ISupportedAsset _assetManager,\r\n        ISafeFactory _safeFactory\r\n    )\r\n        MinimumLiquidity(_assetManager, _baseAsset, _roleManager, _safeFactory)\r\n    {\r\n        if(address(_flexpoolFactory) == address(0)) '_flexpoolFactory is zero'._throw();\r\n        flexpoolFactory = _flexpoolFactory;\r\n    }\r\n\r\n    /**\r\n    * @dev Utility for provide liquidity\r\n    * @notice User must approve this contract with the liquidiy amount prior to this call.\r\n    * @param rate: Interest rate the provider is willing to charge.      \r\n    *   We choose a base value (numerator as 10000) repesenting a 100% of input value. This means if Alice wish to set \r\n    *   her interest rate to 0.05% for instance, she only need to multiply it by 100 i.e 0.05 * 100 = 5. Her input will be 5. \r\n    *   Since Solidity do not accept decimals as input, in our context, the minimum value to parse is '0' indicating \r\n    *   zero interest rate. If user wish to set interest at least, the minimum value will be 1 reprensenting 0.01%.\r\n    *   The minimum interest rate to set is 0.01% if interest must be set at least.\r\n    *   To reiterate, raw interest must be multiplied by 100 before giving as input. \r\n    */\r\n    function provideLiquidity(uint16 rate) public whenNotPaused returns(bool) {\r\n        if(rate >= type(uint16).max) \"Invalid rate\"._throw();\r\n        address sender = _msgSender();\r\n        Data memory data = slots[sender];\r\n        Common.Interest memory interest;\r\n        uint liquidity = _checkAndWithdrawAllowance(baseAsset, sender, address(this), minimumLiquidity);\r\n        unchecked {\r\n            if(!data.hasIndex){\r\n                data.id = providers.length;\r\n                data.hasIndex = true;\r\n                slots[sender] = data;\r\n                providers.push(Common.Provider(data.id, liquidity, rate, 0, sender, interest));\r\n            } else {\r\n                providers[data.id].amount += liquidity;\r\n            }\r\n        }\r\n\r\n        emit LiquidityProvided(providers[data.id]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity.\r\n     * @notice Liquidity can be removed anytime provided the balance exceeds zero\r\n     */\r\n    function removeLiquidity() public whenNotPaused nonReentrant returns(bool) {\r\n        (Common.Provider memory prov, uint slot, address caller) = _getProvider();\r\n        if(prov.amount == 0) \"Nothing to remove\"._throw();\r\n        providers[slot].amount = 0;\r\n        _setApprovalFor(baseAsset, caller, prov.amount);\r\n\r\n        emit LiquidityRemoved(prov);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Users can borrow from liquidity providers to finance a Flexpool\r\n     * @param providersSlots : Selected providers' slots are required \r\n     * @param amount : Amount user wish to borrow.\r\n     */\r\n    function borrow(uint[] memory providersSlots, uint amount) public whenNotPaused returns(bool) {\r\n        if(providersSlots.length == 0) 'List is empty'._throw();\r\n        if(amount == 0) 'Loan amt is 0'._throw();\r\n        Common.Provider[] memory provs = _aggregateLiquidityFromProviders(providersSlots, amount); \r\n        address spender = address(flexpoolFactory);\r\n        _setApprovalFor(baseAsset, spender, amount);\r\n        if(!IFactory(spender).contributeThroughProvider(provs, _msgSender(), amount)) 'Factory erroed'._throw();\r\n\r\n        emit Borrowed(provs, _msgSender());\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Loop through the selected providers balances, and check if there is enough balances\r\n     * to accommodate the requested loan, otherwise operation fails.\r\n     * @param providersSlots : Array of selected providers slots\r\n     * @param amount : Requested loan amount\r\n     * Return a list of providers that financed the contribution\r\n     */\r\n    function _aggregateLiquidityFromProviders(\r\n        uint[] memory providersSlots, \r\n        uint amount\r\n    ) \r\n        internal \r\n        returns(Common.Provider[] memory result)\r\n    {\r\n        uint amountLeft = amount;\r\n        uint providersSize = providersSlots.length;\r\n        Common.Provider[] memory _providers = new Common.Provider[](providersSize);\r\n        for(uint i = 0; i < providersSize; i++) {\r\n            uint slot = providersSlots[i];\r\n            if(slot >= providers.length) 'Invalid slot detected'._throw();\r\n            Common.Provider memory prov = providers[slot];\r\n            unchecked {\r\n                if(prov.amount >= amountLeft) {\r\n                    providers[slot].amount = prov.amount - amountLeft; \r\n                    amountLeft = 0;\r\n                } else {\r\n                    amountLeft -= prov.amount; \r\n                    providers[slot].amount = 0;\r\n                }\r\n            }\r\n\r\n            uint snapshotBal = providers[slot].amount;\r\n            prov.amount -= snapshotBal; // Record actual amount the provider lends to the borrower\r\n            _providers[i] = prov;\r\n            if(amountLeft == 0) break;\r\n        }\r\n        if(amountLeft > 0) 'Loan exceed aggregate providers bal'._throw();\r\n        result = _providers;\r\n    }\r\n\r\n    // ReadOnly function. Return provider's information. \r\n    function _getProvider() \r\n        internal \r\n        view \r\n        returns(Common.Provider memory prov, uint slot, address caller) \r\n    {\r\n        caller = _msgSender();\r\n        Data memory data = slots[caller];\r\n        if(!data.hasIndex) 'User is not a provider'._throw();\r\n        slot = data.id;\r\n        prov = providers[slot];\r\n    }\r\n\r\n    // Returns providers in storage.\r\n    function getProviders() public view returns(Common.Provider[] memory prov) {\r\n        prov = providers;\r\n        return prov;\r\n    }\r\n}"
    },
    "contracts/standalone/Points.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IPoint, Common } from \"../apis/IPoint.sol\";\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\nimport { OnlyRoleBase, IRoleBase } from \"../peripherals/OnlyRoleBase.sol\";\r\n\r\ncontract Points is IPoint, OnlyRoleBase {\r\n    using ErrorLib for *;\r\n\r\n    // All points \r\n    Common.Point[] private points;\r\n\r\n    // Mapping of unit contributors to Initializer struct\r\n    mapping(address users => Initializer) private initializer;\r\n\r\n    constructor(IRoleBase _roleManager) OnlyRoleBase(_roleManager) {} \r\n\r\n    /**\r\n     * @dev Returns the point\r\n     * @param user : Contributor\r\n    */\r\n    function _getPoint(address user) internal view returns(Common.Point memory point){\r\n        Initializer memory init = initializer[user];\r\n        if(init.isRegistered) {\r\n            point = points[init.location];\r\n        }\r\n        return point;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the point\r\n     * See _getPoint\r\n    */\r\n    function getPoint(address user) external view returns(Common.Point memory){\r\n        return _getPoint(user);\r\n    }\r\n\r\n    /**\r\n     * @dev Register user to earn points\r\n     * @notice Users automatically earn free 5 points for signing up\r\n     */\r\n    function registerToEarnPoints() public {\r\n        address sender = _msgSender();\r\n        Initializer memory init = initializer[sender];\r\n        if(init.isRegistered) 'User is registered'._throw();\r\n        init.isRegistered = true;\r\n        init.location = points.length;\r\n        initializer[sender] = init;\r\n        points.push( Common.Point(0, 0, 5, sender));\r\n        \r\n    } \r\n\r\n    /**\r\n     * @dev Update points for the target user if they are already initialized otherwise create a new spot for them. \r\n     * @param user : Unit contribution\r\n     * @param _point : Point struct containing essential data;\r\n    */\r\n    function setPoint(address user, Common.Point memory _point) external onlyRoleBearer returns(bool) {\r\n        Initializer memory init = initializer[user];\r\n        if(init.isRegistered) {\r\n            Common.Point memory point = points[init.location];\r\n            assert(point.user == _point.user);\r\n            unchecked {\r\n                if(_point.contributor > 0) points[init.location].contributor = point.contributor + _point.contributor;\r\n                if(_point.creator > 0) points[init.location].creator = point.creator + _point.creator;\r\n                if(_point.referrals > 0) points[init.location].referrals = point.referrals + _point.referrals;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Update points for the target user if they are already initialized otherwise create a new spot for them. \r\n     * @param user : Unit contribution\r\n     * @param _point : Point struct containing essential data;\r\n    */\r\n    function deductPoint(address user, Common.Point memory _point) external onlyRoleBearer returns(bool) {\r\n        Initializer memory init = initializer[user];\r\n        if(init.isRegistered) {\r\n            Common.Point memory point = points[init.location];\r\n            assert(point.user == _point.user);\r\n            unchecked {\r\n                if(_point.contributor > 0 && point.contributor > _point.contributor) points[init.location].contributor =  point.contributor - _point.contributor;\r\n                if(_point.creator > 0 && point.creator > _point.creator) points[init.location].creator = point.creator - _point.creator;\r\n                if(_point.referrals > 0 && point.referrals > _point.referrals) points[init.location].referrals = point.referrals - _point.referrals;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Retrieve the points array in storage\r\n    function getPoints() public view returns(Common.Point[] memory _points) {\r\n        _points = points;\r\n        return _points;\r\n    }\r\n}"
    },
    "contracts/standalone/SafeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { ISafeFactory } from \"../apis/ISafeFactory.sol\";\r\nimport { Safe, OnlyRoleBase, IRoleBase } from \"../peripherals/Safe.sol\";\r\n\r\n/**@title SafeFactory: A standalone contract that manages safe creation and retrieval, \r\n  deletion, read and write data.\r\n */\r\ncontract SafeFactory is ISafeFactory, OnlyRoleBase {\r\n  // using Clones for address;\r\n\r\n  // Total safe created to date\r\n  uint public totalSafes;\r\n\r\n  // Fee receiver account\r\n  address public feeTo;\r\n\r\n /**\r\n * @dev Mapping of unit contribution to safe.\r\n */\r\n  mapping(uint256 unitContribution => address safeAddresses) private safeMap;\r\n\r\n  /**\r\n   * =========== Constructor ===============\r\n   * @param _roleManager : Role manager contract\r\n   * @param _feeTo : Fee receiver\r\n   */\r\n  constructor (IRoleBase _roleManager, address _feeTo) OnlyRoleBase(_roleManager) {\r\n    feeTo = _feeTo;\r\n  }\r\n\r\n  // Not accepting values\r\n  receive() external payable {\r\n    revert();\r\n  }\r\n  \r\n  /**@dev Return if account owns a safe or not\r\n  */\r\n  function _hasSafe(uint256 unit) internal view returns (bool) {\r\n    return safeMap[unit] != address(0);\r\n  }\r\n\r\n  // Returns Safe for 'user'\r\n  function _getSafe(uint256 unit) internal view returns(address) { \r\n    return safeMap[unit];\r\n  }\r\n  \r\n  /**@dev Create a new safe.\r\n   * @notice 'unit' should not own a safe before now.\r\n   *          only address with owner permission can call.\r\n  */\r\n  function pingSafe(uint256 unit) external onlyRoleBearer returns(address _safe) {\r\n    if(!_hasSafe(unit)){\r\n      _safe = _createSafe(unit);\r\n    } else {\r\n      _safe = _getSafe(unit);\r\n    }\r\n    return _safe;\r\n  }\r\n\r\n  /** @dev Creates a new Safe\r\n  * @param unit : Amount\r\n  * @notice Even if user is trying to rekey or upgrade smartsafe, same amount of fee is required\r\n  * for successful upgrade.\r\n  */\r\n  function _createSafe(uint256 unit) private returns(address safe) {\r\n    totalSafes ++;\r\n    safe = address(new Safe(roleManager, feeTo));\r\n    _updateSafe(unit, safe);\r\n  }\r\n\r\n  /**\r\n   * Update storage with the new Safe instance : {internal}\r\n   * @param unit : Unit amount \r\n   * @param safe : New Safe address\r\n   */\r\n  function _updateSafe(uint256 unit, address safe) private {\r\n    safeMap[unit] = safe;\r\n  }\r\n\r\n  /**\r\n    * Returns then safe for 'unit'\r\n    * @param unit : Unit amount\r\n  */\r\n  function getSafe(uint unit) external view returns(address) { \r\n    return _getSafe(unit);\r\n  }\r\n\r\n  function setFeeTo(address newFeeTo) public onlyRoleBearer {\r\n    feeTo = newFeeTo;\r\n  }\r\n}"
    },
    "contracts/standalone/tokens/test/Faucet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { OnlyRoleBase, MsgSender, IRoleBase } from \"../../../peripherals/OnlyRoleBase.sol\";\r\nimport { IERC20 } from \"../../../apis/IERC20.sol\";\r\nimport { ErrorLib } from \"../../../libraries/ErrorLib.sol\";\r\nimport { Utils } from \"../../../libraries/Utils.sol\";\r\n\r\ncontract Faucet is OnlyRoleBase {\r\n    using ErrorLib for *;\r\n\r\n    struct Tester {\r\n        uint lastColDispensed;\r\n        uint lastBaseDispensed;\r\n        bool isWhitelisted;\r\n    }\r\n\r\n    // Amount of base token to dispense\r\n    uint public baseTokenAmount;\r\n\r\n    // Amount of collateral token to dispense\r\n    uint public collateralTokenAmount;\r\n\r\n    // List of testers\r\n    address[] public testers;\r\n\r\n    // Collateral token\r\n    IERC20 public collateralToken;\r\n\r\n    // Base token\r\n    IERC20 public baseToken;\r\n\r\n    mapping (address => Tester) public testersMap;\r\n\r\n    constructor(\r\n        IRoleBase _roleManager,\r\n        IERC20 _collateralToken,\r\n        IERC20 _baseToken,\r\n        uint _baseTokenAmount,\r\n        uint _colTokenAmount\r\n    ) OnlyRoleBase(_roleManager) {\r\n        if(_collateralToken == collateralToken) \"Collateral token is zero\"._throw();\r\n        (address(_roleManager) != address(0), \"RoleManager addr is zero\");\r\n        collateralToken = _collateralToken;\r\n        baseToken = _baseToken;\r\n        baseTokenAmount = _baseTokenAmount;\r\n        collateralTokenAmount = _colTokenAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Claim test token \r\n     * @param to : Recipient\r\n     * @notice Two assets are sent to recipient:\r\n     *      1. Base contribution asset\r\n     *      2. Collateral token\r\n     *  Sender must registered and be approved in order to claim test tokens\r\n     */\r\n    function _claimTokens(address to) internal {\r\n        uint colAmt = collateralTokenAmount;\r\n        uint baseAmt = baseTokenAmount;\r\n        Tester memory tester = testersMap[to];\r\n\r\n        if(colAmt > 0) {\r\n            uint userBal = IERC20(collateralToken).balanceOf(to);\r\n            if(userBal == 0 && Utils._now() > (tester.lastColDispensed + 24 hours)){\r\n                uint myBal = IERC20(collateralToken).balanceOf(address(this));\r\n                if(myBal >= colAmt) {\r\n                    tester.lastColDispensed = Utils._now();\r\n                    IERC20(collateralToken).transfer(to, colAmt);\r\n                }\r\n            }\r\n        }\r\n\r\n        if(baseAmt > 0) {\r\n            uint userBal = IERC20(baseToken).balanceOf(to);\r\n            if(userBal == 0 && Utils._now() > (tester.lastBaseDispensed + 24 hours)){\r\n                uint myBal = IERC20(baseToken).balanceOf(address(this));\r\n                if(myBal >= baseAmt) {\r\n                    tester.lastBaseDispensed = Utils._now();\r\n                    IERC20(baseToken).transfer(to, baseAmt);\r\n                }\r\n            }\r\n        } \r\n\r\n        if(!tester.isWhitelisted) {\r\n            tester.isWhitelisted = true;\r\n            testers.push(to);\r\n        }\r\n        testersMap[to] = tester;\r\n    }\r\n\r\n    // User claim test tokens\r\n    function claimTestTokens() public returns(bool) {\r\n        _claimTokens(_msgSender());\r\n        return true;\r\n    }\r\n\r\n    // Admin overrides cooldown time to send test tokens to users\r\n    function sendTokens(address to) public onlyRoleBearer returns(bool) {\r\n        _claimTokens(to);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Admin account (s) can send test tokens to multiple users.\r\n     * @param tos : A list of recipients\r\n     * @notice Sender must have role permission\r\n     */\r\n    function mintBatch(address[] memory tos) public onlyRoleBearer returns(bool) {\r\n        for(uint i = 0; i < tos.length; i++) {\r\n            _claimTokens(tos[i]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Set Collateral token\r\n     * @param newToken : New token contract\r\n     */\r\n    function setCollateralToken(IERC20 newToken) public onlyRoleBearer returns(bool) {\r\n        if(newToken == collateralToken || address(newToken) == address(0)) \"New Token is the existing or zero\"._throw();\r\n        collateralToken = newToken;\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Set base token\r\n     * @param newToken : New token contract\r\n     */\r\n    function setBaseToken(IERC20 newToken) public onlyRoleBearer returns(bool) {\r\n        if(newToken == baseToken || address(newToken) == address(0)) \"New Token is the existing or zero\"._throw();\r\n        collateralToken = newToken;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set base amount\r\n     * @param newAmt : New token contract\r\n     */\r\n    function setBaseAmount(uint newAmt) public onlyRoleBearer returns(bool) {\r\n        baseTokenAmount = newAmt;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set Collateral amount\r\n     * @param newAmt : New token contract\r\n     */\r\n    function setCollateralAmount(uint newAmt) public onlyRoleBearer returns(bool) {\r\n        baseTokenAmount = newAmt;\r\n        return true;\r\n    }\r\n\r\n}"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "constantinople",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}