{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/apis/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IERC20 } from './IERC20.sol';\r\n\r\ninterface Common {\r\n    event PoolCreated(Pool);\r\n    event NewContributorAdded(Pool);\r\n    event GetFinanced(Pool);\r\n    event Payback(Pool);\r\n    event Liquidated(Pool);\r\n    event Cancellation(uint unit);\r\n    event PoolEdited(Pool);\r\n\r\n    enum Stage {\r\n        JOIN, \r\n        GET, \r\n        PAYBACK, \r\n        CANCELED,\r\n        ENDED\r\n    }\r\n\r\n    enum Status { AVAILABLE, TAKEN }\r\n\r\n    enum Branch { CURRENT, RECORD }\r\n\r\n    enum Router { PERMISSIONLESS, PERMISSIONED }\r\n\r\n    struct Pool {\r\n        Low low;\r\n        Big big;\r\n        Addresses addrs;\r\n        Router router;\r\n        Stage stage;\r\n        Status status;\r\n    }\r\n\r\n    struct Low {\r\n        uint8 maxQuorum;\r\n        uint8 selector;\r\n        uint24 colCoverage;\r\n        uint32 duration;\r\n        uint8 allGh;\r\n        uint8 userCount;\r\n    }\r\n\r\n    struct Big {\r\n        uint256 unit;\r\n        uint256 currentPool;\r\n        uint96 recordId;\r\n        uint96 unitId;\r\n    }\r\n\r\n    struct Point {\r\n        uint contributor;\r\n        uint creator;\r\n        uint referrals;\r\n    }\r\n\r\n    struct Interest {\r\n        uint fullInterest;\r\n        uint intPerSec;\r\n    }\r\n\r\n    /**\r\n     * @notice Structured types - Address\r\n     * @param asset : Contract address of the asset in use.\r\n     * @param lastPaid: Last contributor who got finance.\r\n     * @param safe : Strategy for each pool or epoch. See Strategy.sol for more details.\r\n     * @param admin : Pool creator.\r\n     * \r\n    */\r\n    struct Addresses {\r\n        IERC20 colAsset;\r\n        address lastPaid;\r\n        address safe;\r\n        address admin;\r\n    }\r\n\r\n    /**\r\n     *  @param isMember : Whether user is a member or not\r\n     *  @param turnStartTime: Time when the contributor's turn start to count.\r\n     *  @param getFinanceTime: Date when loan was disbursed\r\n     *  @param paybackTime: Date which the borrowed fund must be retured\r\n     *  @param loan: Total debts owed by the last fund recipient.\r\n     *  @param colBals: Collateral balances of the last recipient.\r\n     *  @param sentQuota : Whether an user/current msg.sender has received or not.\r\n     *  @param id : Address of the last recipient.\r\n     * @param interestPaid : The amount of interest paid  \r\n    */\r\n    struct Contributor {\r\n        uint32 paybackTime;\r\n        uint32 turnStartTime;\r\n        uint32 getFinanceTime;\r\n        uint loan;\r\n        uint colBals;\r\n        address id;\r\n        bool sentQuota;\r\n    }\r\n\r\n    struct Price {\r\n        uint128 price;\r\n        uint8 decimals;\r\n    }\r\n\r\n    struct Provider {\r\n        uint slot;\r\n        uint amount;\r\n        uint rate;\r\n        uint earnStartDate;\r\n        address account;\r\n        Interest accruals;\r\n    }\r\n\r\n    struct Payback_Safe {\r\n        address user; \r\n        IERC20 baseAsset; \r\n        uint256 debt;\r\n        uint256 attestedInitialBal;\r\n        bool allGF; \r\n        Contributor[] cData;\r\n        bool isSwapped;\r\n        address defaulted;\r\n        uint96 recordId;\r\n        IERC20 collateralAsset;\r\n    }\r\n\r\n    struct Slot {\r\n        uint value;\r\n        bool isMember;\r\n        bool isAdmin;\r\n    }\r\n\r\n    struct ReadDataReturnValue {\r\n        Pool pool;\r\n        Contributor[] cData;\r\n    }\r\n\r\n    struct UpdatePoolData {\r\n        uint unit;\r\n        uint96 unitId;\r\n        uint96 recordId;\r\n        uint8 maxQuorum;\r\n        uint24 colCoverage;\r\n        IERC20 colAsset;\r\n        uint16 durationInHours;\r\n        address creator;\r\n        Router router; \r\n    }\r\n\r\n    struct Analytics {\r\n        uint256 tvlCollateral;\r\n        uint256 tvlBase;\r\n        uint totalPermissioned;\r\n        uint totalPermissionless;\r\n    }\r\n\r\n    struct ViewFactoryData {\r\n        Analytics analytics;\r\n        uint16 makerRate;\r\n        uint currentEpoches;\r\n        uint recordEpoches;\r\n    }\r\n\r\n    struct ContributorReturnValue {\r\n        Contributor profile;\r\n        uint8 slot;\r\n        Common.Provider[] providers;\r\n    }\r\n\r\n}"
    },
    "contracts/apis/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport \"./IERC20Metadata.sol\";\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 is IERC20Metadata{\r\n    error NotCallable();\r\n    error AddressIsZero(address);\r\n    error NoPreviousLockDetected();\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    \r\n    /** \r\n     * @dev Moves `amounts` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event for each transfer.\r\n     * Note: BE AWARE OF THE GAS COST WHEN USING THIS FUNCTION. IT INCREASES \r\n                RELATIVE TO THE ACCOUNTS ARRAY\r\n     */\r\n    function batchTransfer(uint[] memory amounts, address[] memory accounts) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n\r\n    /**@dev Locks specific amount of JFT to the private ledger.\r\n        param: routeTo - Alternative address that funds will be sent to when panic call is made.\r\n        param: amount - Amount to lock.\r\n    */\r\n    function lockToken(address routeTo, uint256 amount) external returns(bool);\r\n\r\n    /**@dev Moves an 'amount' from private ledger to regular balances.\r\n        @param amount - Amount to unlock.\r\n        Note: If the lock duration was set, holder will not be able to unlock until the \r\n            set time has passed else they can withdraw to regular balance anytime.\r\n     */\r\n    function unlockToken(uint amount) external returns(bool);\r\n\r\n    /** @dev Returns seperate balances of @param who\r\n        return value will be in struct format having two values\r\n     */\r\n    function accountBalances(address who) external view returns(Balances memory);\r\n   \r\n    // /**@dev Return JFT's Metadata including the information of `who`\r\n    //  */\r\n    // function getInfo(address who) external view returns(Protected memory);\r\n\r\n    /**\r\n     * @dev PanicUnlock is meant to be invoked only by the Attorney.\r\n     * It should only be called when JFT holder has lost access to their account and they had \r\n     * earlier initiated a lock. The locked token is simply unlocked and sent to an escape address\r\n     * provided at the time the lock was activated.\r\n     * \r\n     * Note: Attorney charges a fee for doing this. \r\n     * @param account : Account that owns this token.\r\n     */\r\n    function panicUnlock(address account, Balances memory _bal) external returns(bool);\r\n\r\n    struct Protected {\r\n        uint256 value; // Total value currently locked\r\n        address escapeTo;\r\n    }\r\n\r\n    struct Balances {\r\n        uint256 spendable;\r\n        Protected locked;\r\n    }\r\n\r\n    struct TokenInfo {\r\n        uint8 decimals;\r\n        uint256 totalSupply;\r\n        string name;\r\n        string symbol;\r\n        address attorney;\r\n        // address rewarder;\r\n    }\r\n}\r\n"
    },
    "contracts/apis/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "contracts/apis/IRoleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title IRoleBase \r\n * Interface of the OwnerShip contract\r\n * @author Simplifi (Bobeu)\r\n */\r\ninterface IRoleBase {\r\n    function setRole(\r\n        address[] memory newRoleTos\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function removeRole(\r\n        address target\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function renounceRole() \r\n        external\r\n        returns(bool);\r\n\r\n    function getRoleBearer(\r\n        uint ownerId\r\n    ) \r\n        external \r\n        view \r\n        returns(address);\r\n\r\n    function hasRole(\r\n        address target\r\n    )\r\n        external\r\n        view \r\n        returns(bool);\r\n}"
    },
    "contracts/libraries/ErrorLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nlibrary ErrorLib {\r\n    error ErrorOccurred(string errorMsg);\r\n\r\n    /**\r\n     * @dev Reverts any operation.\r\n     * @param _error : Error struct\r\n     */\r\n    function _throw(string memory _error) internal pure {\r\n        if(bytes(_error).length > 0){ \r\n            revert ErrorOccurred(_error);\r\n        }\r\n    }\r\n\r\n}"
    },
    "contracts/libraries/Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport { Common } from \"../apis/Common.sol\";\r\nimport { ErrorLib } from \"./ErrorLib.sol\";\r\n\r\nlibrary Utils {\r\n    using Address for address;\r\n    using ErrorLib for *;\r\n\r\n    /**     @dev Calculation of percentage.\r\n        *   This is how we calculate percentage to arrive at expected value with \r\n        *   precision.\r\n        *   We choose a base value (numerator as 10000) repesenting a 100% of the principal value. This means if Alice wish to set \r\n        *   her interest rate to 0.05% for instance, she only need to multiply it by 100 i.e 0.05 * 100 = 5. Her input will be 5. \r\n        *   Since Solidity do not accept decimals as input, in our context, the minimum value to parse is '0' indicating \r\n        *   zero interest rate. If user wish to set interest at least, the minimum value will be 1 reprensenting 0.01%.\r\n        *   The minimum interest rate to set is 0.01% if interest must be set at least.\r\n        *   @notice To reiterate, raw interest must be multiplied by 100 before giving as input. \r\n        *   @param principal : The principal value on which the interest is based. Value should be in decimals.\r\n        *   @param interest : Interest rate. \r\n        *   \r\n        *   Rules\r\n        *   -----\r\n        *   - Principal cannot be less than base.\r\n        *   - Interest cannot be greater than (2 ^ 16) - 1\r\n    */\r\n    function _getPercentage(\r\n        uint principal, \r\n        uint16 interest\r\n    )\r\n        internal \r\n        pure \r\n        returns (uint _return) \r\n    {\r\n        uint16 base = _getBase(); \r\n        if(interest == 0 || principal == 0) return 0;\r\n        if(interest >= type(uint16).max) 'Interest overflow'._throw(); \r\n        if(principal <= base) 'Principal should be greater than 10000'._throw();\r\n        unchecked {\r\n            _return = (principal * interest) / base;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Percentage base\r\n     */\r\n    function _getBase() internal pure returns(uint16 base) {\r\n        base = 10000;\r\n    }\r\n    \r\n    function _decimals(address asset) internal view returns(uint8 decimals) {\r\n        decimals = IERC20Metadata(asset).decimals();\r\n    }\r\n\r\n    /**\r\n     * @dev Computes collateral on the requested loan amount\r\n     * @param ccr : Collateral ratio. Must be multiply by 100 before parsing as input i.e if raw ccr\r\n     *              is 1.2, it should be rendered as 1.2 * 100 = 120.\r\n     * @param price : Price of Collateral token base with decimals.\r\n     * @param loanReqInDecimals : Total requested contribution in USD\r\n     * @notice Based on Simplifi mvp, loans are collaterized in XFI until we add more pairs\r\n     *         in the future.\r\n     * Example: Alice, Bob and Joe formed a band to contribute $100 each where duration is for \r\n     * 10 days each. Alice being the admin set ccr to 1.5 equivalent to 150% of the total sum \r\n     * contribution of $300. If the price of XFI as at the time of GF is $0.5/XFI, where XFI decimals\r\n     * is in 18, we calculate the required XFI to stake as follows:   \r\n     *  \r\n     *                    totalContribution *  (10** XFIdecimals)   |                 raw ccr\r\n     *   totalLoanInXFI = --------------------------------------    |    actualCCR = (1.5 * 100) * 100 = 1500\r\n     *                        (xfiPriceIndecimals)                  |\r\n     * \r\n     *                     totalLoanInXFI * actualCCR\r\n     *        XFINeeded = ----------------------------\r\n     *                             _getBase()\r\n     * \r\n     *  Therefore, Alice is required to stake 900XFI to GF $300 for 10 days.\r\n     *   \r\n     */\r\n    function computeCollateral(\r\n        Common.Price memory price,\r\n        uint24 ccr,\r\n        uint loanReqInDecimals\r\n    ) \r\n        internal\r\n        pure \r\n        returns(uint256 expCol) \r\n    {\r\n        // uint8 minCCR = 100;\r\n        // if(ccr < minCCR) revert CollateralCoverageCannotGoBelow_100();\r\n        if(ccr == 0) expCol = 0;\r\n        else {\r\n            unchecked {\r\n                uint48 _ccr = uint48(ccr * 100);\r\n                uint totalLoan = (loanReqInDecimals * (10**price.decimals)) / price.price;\r\n                expCol = (totalLoan * _ccr) / _getBase();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @dev Computes maker fee.\r\n        @param makerRate : The amount of fee (in %) charged by the platform on the principal given to a borrower.\r\n            Note : Raw rate must multiply by 100 to get the expected value i.e\r\n            if maker rate is 0.1%, it should be parsed as 0.1 * 100 = 10.\r\n            See `_getPercentage()`.\r\n        @param amount should be in decimals.\r\n    */\r\n    function computeFee(\r\n        uint amount, \r\n        uint16 makerRate\r\n    ) \r\n        internal \r\n        pure \r\n        returns (uint mFee) \r\n    {\r\n        mFee = _getPercentage(amount, makerRate);\r\n    }\r\n\r\n    /**\r\n     * @dev Compute interest based on specified rate.\r\n     * @param rate : Interest rate.\r\n     * @param principal : Total expected contribution.\r\n     * @param fullDurationInSec : Total duration.\r\n     * \r\n     * Rules\r\n     * -----\r\n     * - Duration cannot exceed 30days i.e 2592000 seconds uint24 seconds\r\n     */\r\n    function computeInterestsBasedOnDuration(\r\n        uint principal,\r\n        uint16 rate,\r\n        uint32 fullDurationInSec\r\n    )\r\n        internal \r\n        pure \r\n        returns(Common.Interest memory it) \r\n    {\r\n        assert(fullDurationInSec <= _maxDurationInSec());\r\n        it.fullInterest = _getPercentage(principal, rate); // Full interest for fullDurationInSec\r\n        if(it.fullInterest > 0) {\r\n            unchecked {\r\n                it.intPerSec = (it.fullInterest * 1) / fullDurationInSec;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Max duration : 30Days, presented in seconds\r\n     */\r\n    function _maxDurationInSec() internal pure returns(uint24 max) {\r\n        max = 2592000;\r\n    }\r\n\r\n    function _now() internal view returns(uint64 date) {\r\n        date = uint64(block.timestamp);\r\n    }\r\n\r\n}"
    },
    "contracts/peripherals/OnlyRoleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IRoleBase } from \"../apis/IRoleBase.sol\";\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\n\r\n/**\r\n * @title MsgSender \r\n * @author Simplifi (Bobeu)\r\n * @notice Non-deployable contract simply returning the calling account.\r\n */\r\nabstract contract MsgSender {\r\n    function _msgSender() internal view virtual returns(address sender) {\r\n        sender = msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract OnlyRoleBase is MsgSender {\r\n    using ErrorLib for *;\r\n\r\n    // Role manager address\r\n    IRoleBase public roleManager;\r\n\r\n    // ============= constructor ============\r\n    constructor(IRoleBase _roleManager)\r\n    {\r\n        _setRoleManager(_roleManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Caller must have owner role before execeution can proceed.\r\n     * The 'errorMessage' argument can be used to return error specific to \r\n     * a context e.g function call. \r\n     */\r\n    modifier onlyRoleBearer {\r\n        _onlyRoleBearer();\r\n        _;\r\n    }\r\n\r\n    // Allow only account with role access\r\n    function _onlyRoleBearer() internal view {\r\n        IRoleBase mgr = roleManager;\r\n        if(address(mgr) == address(0)) 'Manager is zero'._throw();\r\n        if(!_hasRole(_msgSender())) 'Access denied'._throw();\r\n    }\r\n\r\n    function _hasRole(address target) internal view returns(bool result) {\r\n        result = IRoleBase(roleManager).hasRole(target);\r\n    }  \r\n\r\n    /// @dev Set role manager\r\n    function _setRoleManager(IRoleBase newManager) private{\r\n        roleManager = newManager;\r\n    }\r\n\r\n    /**\r\n     * Set Role manager\r\n     * @param newManager : New manager address\r\n     */\r\n    function setRoleManager(\r\n        address newManager\r\n    )\r\n        public\r\n        onlyRoleBearer\r\n        returns(bool)\r\n    {\r\n        _setRoleManager(IRoleBase(newManager));\r\n        return true;\r\n    }\r\n}"
    },
    "contracts/peripherals/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { OnlyRoleBase, IRoleBase } from \"./OnlyRoleBase.sol\";\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n * \r\n * We use part of the Openzeppelin Pausable contract to supplement our strategy.\r\n * Thanks to the OZ team.\r\n */\r\nabstract contract Pausable is OnlyRoleBase {\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is paused.\r\n     */\r\n    error EnforcedPause();\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is not paused.\r\n     */\r\n    error ExpectedPause();\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor(\r\n        IRoleBase _roleManager\r\n    ) OnlyRoleBase(_roleManager) {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view {\r\n        if (paused()) {\r\n            revert EnforcedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        if (!paused()) {\r\n            revert ExpectedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     * Only owner role can call.\r\n     * - The contract must not be paused.\r\n     */\r\n    function pause() \r\n        public \r\n        onlyRoleBearer\r\n        whenNotPaused \r\n    {\r\n        _paused = true; \r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     * - Only owner role can call.\r\n     * - The contract must be paused.\r\n     */\r\n    function unpause() \r\n        public \r\n        onlyRoleBearer \r\n        whenPaused \r\n    {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n"
    },
    "contracts/peripherals/token/ERC20Abstract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IERC20 } from \"../../apis/IERC20.sol\";\r\nimport { Pausable, IRoleBase } from \"../Pausable.sol\";\r\n\r\nlibrary Lib {\r\n  function cannotBeEmptyAddress(address target) internal pure {\r\n    require(target != address(0), \"Lib: Target is zero address\");\r\n  }\r\n\r\n  function mustBeAbove(uint a, uint b) internal pure {\r\n    require(a >= b, \"B is greater than A\");\r\n  }\r\n\r\n  function _now() internal view returns(uint64 result) {\r\n    result = uint64(block.timestamp);\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * The default value of {decimals} is 18. To change this, you should override\r\n * this function so it returns a different value.\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\n\r\n/**\r\n * @title SimpliFinance Token Implementation { Non deployable }\r\n * @author SimpliFinance - https://github.com/bobeu\r\n * @notice @dev Simplifinance Token operates a dual ledger model:\r\n     *      - Regular balance : Compatible with the standard ERC20 balances.\r\n     *      - private balance : This is kept in a seperate ledger but reflects in the total balances when \r\n     *          the `balanceOf` is invoked. We introduced this method for internal security reasons to protect\r\n     *          SPT holder in the event they lost access to their wallets.\r\n     *  HOW IS WORKS\r\n     *  ============\r\n     *      To be protected, holder must explicitly subscribe to it. During the processs, an alternative \r\n     *      EOA referred to as `escapeTo` must be provided as an argument to the function. Holders are adviced to create a seperate account for this purpose\r\n     *      and keep the private keys secure. Such account might not be used for regular transaction. Providing this address activates \r\n     *      the private balance mode. The specified amount of `inValue` is locked for the period of `lockTil`. During the locked period, if holder \r\n     *      lost access to their account, through the `Attorney` contract, provided the lock is activated, they will regain access to their funds.\r\n     *      The Attorney will enquire from the Token contract if the caller has previously activated the lock, and if an escape address was set. otherwise\r\n     *      the request is ignored.\r\n     * Note: An amount is charged by the Attorney for such service.\r\n     * Even if an hacker gained access to your private keys, as a SPT holder, the fund is not accessible to them only if the holder had activated the lock feature.\r\n     * \r\n     * Note: The call must be initiated by an account other than the owner.\r\n     *       An attacker only has access to SPT token in your regular ERC20 ledger balances.\r\n     *   \r\n        The `panicWithdraw` method resides in the Attorney contract. It unlocks all balances in the locked ledger and are sent to the `escape` account provided the  \r\n        an address was initially set.\r\n */\r\nabstract contract ERC20Abstract is IERC20, Pausable {\r\n  using Lib for *;\r\n\r\n  TokenInfo private tokenInfo;\r\n  \r\n  mapping(address => Balances) private _balances;\r\n\r\n  mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n  /**\r\n   * @dev Initializes state varibles.\r\n   * Note: We mint the maxSupply at deployment. 30% of the total supply\r\n   * is in circulation while the rest is lcoked in the reserve.\r\n   */\r\n  constructor(\r\n    address attorney_,\r\n    address reserve_,\r\n    address initTokenReceiver,\r\n    IRoleBase _roleManager\r\n  )  \r\n    Pausable(_roleManager)\r\n  {\r\n    attorney_.cannotBeEmptyAddress();\r\n    tokenInfo = TokenInfo(18, 0, \"Simplfinance Token\", \"TSFT\", attorney_);\r\n    // _mint(_msgSender(), 200000*(10**18)); // For testing, mint to msg.sender\r\n    _mint(initTokenReceiver, 1_000_000_000*(10**18));\r\n    _lock(initTokenReceiver, reserve_, 700_000_000*(10**18)); // We expect reserve_ to be a grouped account e.g multisig.\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the name of the token.\r\n   */\r\n  function name() public view virtual override returns (string memory) {\r\n    return tokenInfo.name;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the symbol of the token, usually a shorter version of the\r\n   * name.\r\n   */\r\n  function symbol() public view virtual override returns (string memory) {\r\n    return tokenInfo.symbol;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of decimals used to get its user representation.\r\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n   *\r\n   * Tokens usually opt for a value of 18, imitating the relationship between\r\n   * Ether and Wei. This is the default value returned by this function, unless\r\n   * it's overridden.\r\n   *\r\n   * NOTE: This information is only used for _display_ purposes: it in\r\n   * no way affects any of the arithmetic of the contract, including\r\n   * {IERC20-balanceOf} and {IERC20-transfer}.\r\n   */\r\n  function decimals() public view virtual override returns (uint8) {\r\n    return tokenInfo.decimals;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns contracts account connected to the token contracts i.e.\r\n   *    - Attorney\r\n   * Note: Attorney account acts on behalf of a holders to retrive their token\r\n   *        in the event they lost access to their accounts.\r\n   */\r\n  function getAttorney() public view returns(address _attorney) {\r\n    _attorney = tokenInfo.attorney;\r\n  }\r\n\r\n  /// @dev See IERC20.sol {getInfo}\r\n  function getLockedInfo(address target) public view returns(Protected memory _locked) {\r\n    address msgSender = _msgSender();\r\n    if(msgSender == tokenInfo.attorney) {\r\n      _locked = _balances[target].locked;\r\n    }\r\n    return _locked;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-totalSupply}.\r\n   */\r\n  function totalSupply() public view virtual override returns (uint256) {\r\n    return tokenInfo.totalSupply;\r\n  }\r\n\r\n  ///@dev See {IERC20-accountBalances}.\r\n  function accountBalances(address who) external view returns (Balances memory _bal) {\r\n    _bal = _balances[who];\r\n    return _bal;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-balanceOf}.\r\n   * Returns the spendable balance of @param account: Bytes32 address type\r\n   * Note: The function `balanceOf` complies with that ERC20 standard\r\n   */\r\n  function balanceOf(address account) public view returns (uint256 _bal) {\r\n    return _getSpendable(account);\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-transfer}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `to` cannot be the zero address.\r\n   * - the caller must have a balance of at least `amount`.\r\n   */\r\n  function transfer(address to, uint256 amount) public returns (bool) {\r\n    address owner = _msgSender();\r\n    _transfer(owner, to, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-allowance}.\r\n   */\r\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-approve}.\r\n   *\r\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n      address owner = _msgSender();\r\n      _approve(owner, spender, amount);\r\n      return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-transferFrom}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance. This is not\r\n   * required by the EIP. See the note at the beginning of {ERC20}.\r\n   *\r\n   * NOTE: Does not update the allowance if the current allowance\r\n   * is the maximum `uint256`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` and `to` cannot be the zero address.\r\n   * - `from` must have a balance of at least `amount`.\r\n   * - the caller must have allowance for ``from``'s tokens of at least\r\n   * `amount`.\r\n   */\r\n  function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\r\n    address spender = _msgSender();\r\n    _spendAllowance(from, spender, amount);\r\n    _transfer(from, to, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {IERC20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n      address owner = _msgSender();\r\n      _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n      return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {IERC20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   * - `spender` must have allowance for the caller of at least\r\n   * `subtractedValue`.\r\n   */\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns(bool) {\r\n    address owner = _msgSender();\r\n    uint256 currentAllowance = allowance(owner, spender);\r\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n    unchecked {\r\n      _approve(owner, spender, currentAllowance - subtractedValue);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // Returns spendable balances of {from} i.e usual ERC20 'balanceOf'\r\n  function _getSpendable(address from) internal view returns (uint256) {\r\n    return _balances[from].spendable;\r\n  }\r\n\r\n  /**\r\n   * @dev Moves `amount` of tokens from `from` to `to`.\r\n   *\r\n   * This internal function is equivalent to {transfer}, and can be used to\r\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `from` must have a balance of at least `amount`.\r\n   */\r\n  function _transfer(address from, address to, uint256 amount) internal virtual \r\n  {\r\n    from.cannotBeEmptyAddress();\r\n    to.cannotBeEmptyAddress();\r\n\r\n    _beforeTokenTransfer(from, to, amount);\r\n    uint256 fromBalance = _getSpendable(from);\r\n    fromBalance.mustBeAbove(amount);\r\n    unchecked {\r\n        _balances[from].spendable = fromBalance - amount;\r\n        // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n        // decrementing then incrementing.\r\n        _balances[to].spendable += amount;\r\n    }\r\n\r\n    emit Transfer(from, to, amount);\r\n\r\n    _afterTokenTransfer(from, to, amount);\r\n  }\r\n\r\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n   * the total supply.\r\n   *\r\n   * Emits a {Transfer} event with `from` set to the zero address.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `account` cannot be the zero address.\r\n   */\r\n  function _mint(address account, uint256 amount) internal virtual {\r\n    // _requireContext(_isCallable(Internal.MINT));\r\n    account.cannotBeEmptyAddress();\r\n    _beforeTokenTransfer(address(0), account, amount);\r\n\r\n    tokenInfo.totalSupply += amount;\r\n    unchecked {\r\n        // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n        _balances[account].spendable += amount;\r\n    }\r\n    emit Transfer(address(0), account, amount);\r\n\r\n    _afterTokenTransfer(address(0), account, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys `amount` tokens from `account`, reducing the\r\n   * total supply.\r\n   *\r\n   * Emits a {Transfer} event with `to` set to the zero address.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `account` cannot be the zero address.\r\n   * - `account` must have at least `amount` tokens.\r\n   */\r\n  function _burn(address account, uint256 amount) internal virtual {\r\n    account.cannotBeEmptyAddress();\r\n    _beforeTokenTransfer(account, address(0), amount);\r\n\r\n    uint256 accountBalance = _balances[account].spendable;\r\n    accountBalance.mustBeAbove(amount);\r\n    unchecked {\r\n      _balances[account].spendable = accountBalance - amount;\r\n      // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n      tokenInfo.totalSupply -= amount;\r\n    }\r\n\r\n    emit Transfer(account, address(0), amount);\r\n\r\n    _afterTokenTransfer(account, address(0), amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n   *\r\n   * This internal function is equivalent to `approve`, and can be used to\r\n   * e.g. set automatic allowances for certain subsystems, etc.\r\n   *\r\n   * Emits an {Approval} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `owner` cannot be the zero address.\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n    owner.cannotBeEmptyAddress();\r\n    spender.cannotBeEmptyAddress();\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n   *\r\n   * Does not update the allowance amount in case of infinite allowance.\r\n   * Revert if not enough allowance is available.\r\n   *\r\n   * Might emit an {Approval} event.\r\n   */\r\n  function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n    uint256 currentAllowance = allowance(owner, spender);\r\n    if (currentAllowance != type(uint256).max) {\r\n      currentAllowance.mustBeAbove(amount);\r\n      unchecked {\r\n        _approve(owner, spender, currentAllowance - amount);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Hook that is called before any transfer of tokens. This includes\r\n   * minting and burning.\r\n   *\r\n   * Calling conditions:\r\n   *\r\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n   * will be transferred to `to`.\r\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n   * - `from` and `to` are never both zero.\r\n   *\r\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n   */\r\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n\r\n  /**\r\n   * @dev Hook that is called after any transfer of tokens. This includes\r\n   * minting and burning.\r\n   *\r\n   * Calling conditions:\r\n   *\r\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n   * has been transferred to `to`.\r\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n   * - `from` and `to` are never both zero.\r\n   *\r\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n   */\r\n  function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n\r\n  \r\n  ///@dev Returns current Unix time stamp\r\n  function _now() internal view returns(uint32) {\r\n    return uint32(block.timestamp);\r\n  }\r\n  \r\n  /**@dev Locks token in the private ledger balances.\r\n    When tokens are locked they can be unlocked at any time.\r\n      @param _escapeTo : An extra address that token will be forwarded to. This must not be zero address\r\n      @param amount : Amount user is willing to send to the safe.\r\n      Note: If caller has no lock previously set,`escapeTo` must not be an empty address.\r\n            User will always have to provide an escape address each time they want to lock up tokens.\r\n      REWARD\r\n      ======\r\n      Holders are eligible to claim reward if they hold SFT in private ledger for at least 30 days.\r\n      The measure of such reward is determined by the team.\r\n      @notice Care must be taken when locking and unlocking. Users must first check through the attorney if they're\r\n            qualify for reward then they must claim first before lock again, otherwise, the locked time is overriden.\r\n            This can nullify their rewards.\r\n\r\n   */\r\n  function _lock(address account, address _escapeTo, uint256 amount) \r\n    internal\r\n  {\r\n    _escapeTo.cannotBeEmptyAddress();\r\n    Balances memory balances = _balances[account];\r\n\r\n    balances.spendable.mustBeAbove(amount);\r\n    // _balances[account].locked.escapeTo = _escapeTo;\r\n    // _balances[account].locked.lastLocked = amount;\r\n    unchecked {\r\n      _balances[account] = Balances(\r\n        balances.spendable - amount,\r\n        Protected(\r\n          balances.locked.value + amount,\r\n          _escapeTo\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  /**@dev Unlock token \r\n   */\r\n  function _unlock(address account, uint amount) internal {\r\n    Balances memory balances = _balances[account];\r\n    if(balances.locked.escapeTo == address(0)) revert NoPreviousLockDetected();\r\n    balances.locked.value.mustBeAbove(amount);\r\n    unchecked {\r\n      _balances[account].locked.value -= amount;\r\n      _balances[balances.locked.escapeTo].spendable += amount;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Replaces the attorney account. Only authorized owner account can perform\r\n   * this action.\r\n   */\r\n  function setAttorney(address newAttorney) public onlyRoleBearer {\r\n    newAttorney.cannotBeEmptyAddress();\r\n    tokenInfo.attorney = newAttorney;\r\n  }\r\n\r\n  /**See IERC20.sol {panicUnlock}\r\n    Method is executed only of the caller is the attorney\r\n    Note: Since the user is able to prove to the attorney that they\r\n    own the lost account, they are also able to reclaim all balances.\r\n   */ \r\n  function panicUnlock(address accountToRetrieve, Balances memory _bal) external returns(bool feedback) {\r\n    tokenInfo.attorney.cannotBeEmptyAddress();\r\n    if(_msgSender() == tokenInfo.attorney) {\r\n      unchecked {\r\n        _balances[accountToRetrieve].locked.value = 0;\r\n        _balances[_bal.locked.escapeTo].spendable += _bal.locked.value;\r\n      }\r\n      if(_bal.spendable > 0) {\r\n        _transfer(accountToRetrieve, _bal.locked.escapeTo, _bal.spendable);\r\n      } \r\n      feedback = true;\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/standalone/tokens/SimpliToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { ERC20Abstract, IRoleBase } from \"../../peripherals/token/ERC20Abstract.sol\";\r\n\r\n/*\r\n    @title SToken is the native token of the Simplifinance platform.\r\n            It is a utility token that gives its holders access to Simplifinance\r\n            products.\r\n        Standard: Custom and ERC20 compatible.\r\n        Type: Deflationary.\r\n        Max Supply: 1_000_000_000.\r\n        Decimal: 18.\r\n*/\r\ncontract SimpliToken is ERC20Abstract {\r\n    event Locked(address from, uint256 amount);\r\n    event UnLocked(address from, uint256 amount);\r\n\r\n    constructor( \r\n        address attorney_,\r\n        address reserve_,\r\n        address initTokenReceiver,\r\n        IRoleBase _roleManager\r\n    ) ERC20Abstract(attorney_, reserve_, initTokenReceiver, _roleManager) { }\r\n\r\n    ///@dev Contract accepts no platform coin\r\n    receive() external payable {\r\n        revert(\"NA\");\r\n    }\r\n\r\n    ///@dev See IERC20.sol {lockToken}\r\n    function lockToken(address _routeTo, uint256 amount) public returns (bool) {\r\n        _lock(_msgSender(), _routeTo, amount);\r\n\r\n        emit Locked(_msgSender(), amount);\r\n        return true;\r\n    }\r\n\r\n    ///@dev See IERC20.sol {unlock}\r\n    function unlockToken(uint256 amount) public returns (bool) {\r\n        _unlock(_msgSender(), amount);\r\n\r\n        emit UnLocked(_msgSender(), amount);\r\n        return true;\r\n    }\r\n\r\n    ///@dev Burns token of `amount`\r\n    function burn(uint amount) public {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    /**\r\n        See IERC20.sol {batchTransfer}\r\n        A dynamic transfer utility. \r\n        Note: The size of the amount array must match that of the \r\n        account's. Another benefit is that each of the addresses on the \r\n        list can be dynamically mapped to different amount.\r\n     */\r\n    function batchTransfer(\r\n        uint[] memory amounts,\r\n        address[] memory accounts\r\n    ) public override returns (bool) {\r\n        uint accountSize = accounts.length;\r\n        require(accountSize == amounts.length, \"Unequal list\");\r\n        for (uint i = 0; i < accountSize; i++) {\r\n            address to = accounts[i];\r\n            uint amount = amounts[i];\r\n            _transfer(_msgSender(), to, amount);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/standalone/tokens/test/BaseAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { ERC20, Context } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport { IERC20 } from \"../../../apis/IERC20.sol\";\r\n\r\ncontract BaseAsset is ERC20 {\r\n  constructor() ERC20(\"Base Asset\", \"BSD\") {\r\n    _mint(msg.sender, 100000 * (10**18));\r\n  }\r\n\r\n  function mint(address[] memory tos, uint amount) public returns(bool) {\r\n    for(uint i = 0; i < tos.length; i++) {\r\n      _mint(tos[i], amount);\r\n    }\r\n    return true;\r\n  }\r\n  \r\n}"
    },
    "contracts/standalone/tokens/test/Faucet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { OnlyRoleBase, MsgSender, IRoleBase } from \"../../../peripherals/OnlyRoleBase.sol\";\r\nimport { IERC20 } from \"../../../apis/IERC20.sol\";\r\nimport { ErrorLib } from \"../../../libraries/ErrorLib.sol\";\r\nimport { Utils } from \"../../../libraries/Utils.sol\";\r\n\r\ncontract Faucet is OnlyRoleBase {\r\n    using ErrorLib for *;\r\n\r\n    struct Tester {\r\n        uint lastColDispensed;\r\n        uint lastBaseDispensed;\r\n        bool isWhitelisted;\r\n    }\r\n\r\n    // Amount of base token to dispense\r\n    uint public baseTokenAmount;\r\n\r\n    // Amount of collateral token to dispense\r\n    uint public collateralTokenAmount;\r\n\r\n    // List of testers\r\n    address[] public testers;\r\n\r\n    // Collateral token\r\n    IERC20 public collateralToken;\r\n\r\n    // Base token\r\n    IERC20 public baseToken;\r\n\r\n    mapping (address => Tester) public testersMap;\r\n\r\n    constructor(\r\n        IRoleBase _roleManager,\r\n        IERC20 _collateralToken,\r\n        IERC20 _baseToken,\r\n        uint _baseTokenAmount,\r\n        uint _colTokenAmount\r\n    ) OnlyRoleBase(_roleManager) {\r\n        if(_collateralToken == collateralToken) \"Collateral token is zero\"._throw();\r\n        (address(_roleManager) != address(0), \"RoleManager addr is zero\");\r\n        collateralToken = _collateralToken;\r\n        baseToken = _baseToken;\r\n        baseTokenAmount = _baseTokenAmount;\r\n        collateralTokenAmount = _colTokenAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Claim test token \r\n     * @param to : Recipient\r\n     * @notice Two assets are sent to recipient:\r\n     *      1. Base contribution asset\r\n     *      2. Collateral token\r\n     *  Sender must registered and be approved in order to claim test tokens\r\n     */\r\n    function _claimTokens(address to) internal {\r\n        uint colAmt = collateralTokenAmount;\r\n        uint baseAmt = baseTokenAmount;\r\n        Tester memory tester = testersMap[to];\r\n\r\n        if(colAmt > 0) {\r\n            uint userBal = IERC20(collateralToken).balanceOf(to);\r\n            if(userBal == 0 && Utils._now() > (tester.lastColDispensed + 24 hours)){\r\n                uint myBal = IERC20(collateralToken).balanceOf(address(this));\r\n                if(myBal >= colAmt) {\r\n                    tester.lastColDispensed = Utils._now();\r\n                    IERC20(collateralToken).transfer(to, colAmt);\r\n                }\r\n            }\r\n        }\r\n\r\n        if(baseAmt > 0) {\r\n            uint userBal = IERC20(baseToken).balanceOf(to);\r\n            if(userBal == 0 && Utils._now() > (tester.lastBaseDispensed + 24 hours)){\r\n                uint myBal = IERC20(baseToken).balanceOf(address(this));\r\n                if(myBal >= baseAmt) {\r\n                    tester.lastBaseDispensed = Utils._now();\r\n                    IERC20(baseToken).transfer(to, baseAmt);\r\n                }\r\n            }\r\n        } \r\n\r\n        if(!tester.isWhitelisted) {\r\n            tester.isWhitelisted = true;\r\n            testers.push(to);\r\n        }\r\n        testersMap[to] = tester;\r\n    }\r\n\r\n    // User claim test tokens\r\n    function claimTestTokens() public returns(bool) {\r\n        _claimTokens(_msgSender());\r\n        return true;\r\n    }\r\n\r\n    // Admin overrides cooldown time to send test tokens to users\r\n    function sendTokens(address to) public onlyRoleBearer returns(bool) {\r\n        _claimTokens(to);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Admin account (s) can send test tokens to multiple users.\r\n     * @param tos : A list of recipients\r\n     * @notice Sender must have role permission\r\n     */\r\n    function mintBatch(address[] memory tos) public onlyRoleBearer returns(bool) {\r\n        for(uint i = 0; i < tos.length; i++) {\r\n            _claimTokens(tos[i]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Set Collateral token\r\n     * @param newToken : New token contract\r\n     */\r\n    function setCollateralToken(IERC20 newToken) public onlyRoleBearer returns(bool) {\r\n        if(newToken == collateralToken || address(newToken) == address(0)) \"New Token is the existing or zero\"._throw();\r\n        collateralToken = newToken;\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Set base token\r\n     * @param newToken : New token contract\r\n     */\r\n    function setBaseToken(IERC20 newToken) public onlyRoleBearer returns(bool) {\r\n        if(newToken == baseToken || address(newToken) == address(0)) \"New Token is the existing or zero\"._throw();\r\n        collateralToken = newToken;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set base amount\r\n     * @param newAmt : New token contract\r\n     */\r\n    function setBaseAmount(uint newAmt) public onlyRoleBearer returns(bool) {\r\n        baseTokenAmount = newAmt;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set Collateral amount\r\n     * @param newAmt : New token contract\r\n     */\r\n    function setCollateralAmount(uint newAmt) public onlyRoleBearer returns(bool) {\r\n        baseTokenAmount = newAmt;\r\n        return true;\r\n    }\r\n\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "constantinople",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}