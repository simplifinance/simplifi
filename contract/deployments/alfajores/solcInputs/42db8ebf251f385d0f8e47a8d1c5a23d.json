{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/apis/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IERC20 } from './IERC20.sol';\r\n\r\ninterface Common {\r\n    event PoolCreated(Pool);\r\n    event NewContributorAdded(Pool);\r\n    event GetFinanced(Pool);\r\n    event Payback(Pool);\r\n    event Liquidated(Pool);\r\n    event Cancellation(uint unit);\r\n    event PoolEdited(Pool);\r\n\r\n    enum Stage {\r\n        JOIN, \r\n        GET, \r\n        PAYBACK, \r\n        CANCELED,\r\n        ENDED\r\n    }\r\n\r\n    enum Status { AVAILABLE, TAKEN }\r\n\r\n    enum Branch { CURRENT, RECORD }\r\n\r\n    enum Router { PERMISSIONLESS, PERMISSIONED }\r\n\r\n    struct Pool {\r\n        Low low;\r\n        Big big;\r\n        Addresses addrs;\r\n        Router router;\r\n        Stage stage;\r\n        Status status;\r\n    }\r\n\r\n    struct Low {\r\n        uint8 maxQuorum;\r\n        uint8 selector;\r\n        uint24 colCoverage;\r\n        uint32 duration;\r\n        uint8 allGh;\r\n        uint8 userCount;\r\n    }\r\n\r\n    struct Big {\r\n        uint256 unit;\r\n        uint256 currentPool;\r\n        uint96 recordId;\r\n        uint96 unitId;\r\n    }\r\n\r\n    struct Point {\r\n        uint contributor;\r\n        uint creator;\r\n        uint referrals;\r\n        address user;\r\n    }\r\n\r\n    struct Interest {\r\n        uint fullInterest;\r\n        uint intPerSec;\r\n    }\r\n\r\n    /**\r\n     * @notice Structured types - Address\r\n     * @param asset : Contract address of the asset in use.\r\n     * @param lastPaid: Last contributor who got finance.\r\n     * @param safe : Strategy for each pool or epoch. See Strategy.sol for more details.\r\n     * @param admin : Pool creator.\r\n     * \r\n    */\r\n    struct Addresses {\r\n        IERC20 colAsset;\r\n        address lastPaid;\r\n        address safe;\r\n        address admin;\r\n    }\r\n\r\n    /**\r\n     *  @param isMember : Whether user is a member or not\r\n     *  @param turnStartTime: Time when the contributor's turn start to count.\r\n     *  @param getFinanceTime: Date when loan was disbursed\r\n     *  @param paybackTime: Date which the borrowed fund must be retured\r\n     *  @param loan: Total debts owed by the last fund recipient.\r\n     *  @param colBals: Collateral balances of the last recipient.\r\n     *  @param sentQuota : Whether an user/current msg.sender has received or not.\r\n     *  @param id : Address of the last recipient.\r\n     * @param interestPaid : The amount of interest paid  \r\n    */\r\n    struct Contributor {\r\n        uint32 paybackTime;\r\n        uint32 turnStartTime;\r\n        uint32 getFinanceTime;\r\n        uint loan;\r\n        uint colBals;\r\n        address id;\r\n        bool sentQuota;\r\n    }\r\n\r\n    struct Price {\r\n        uint128 price;\r\n        uint8 decimals;\r\n    }\r\n\r\n    struct Provider {\r\n        uint slot;\r\n        uint amount;\r\n        uint rate;\r\n        uint earnStartDate;\r\n        address account;\r\n        Interest accruals;\r\n    }\r\n\r\n    struct Payback_Safe {\r\n        address user; \r\n        IERC20 baseAsset; \r\n        uint256 debt;\r\n        uint256 attestedInitialBal;\r\n        bool allGF; \r\n        Contributor[] cData;\r\n        bool isSwapped;\r\n        address defaulted;\r\n        uint96 recordId;\r\n        IERC20 collateralAsset;\r\n    }\r\n\r\n    struct Slot {\r\n        uint value;\r\n        bool isMember;\r\n        bool isAdmin;\r\n    }\r\n\r\n    struct ReadPoolDataReturnValue {\r\n        Pool pool;\r\n        ContributorReturnValue[] cData;\r\n    }\r\n\r\n    struct ReadRecordDataReturnValue {\r\n        Pool pool;\r\n        Contributor[] cData;\r\n    }\r\n\r\n    struct UpdatePoolData {\r\n        uint unit;\r\n        uint96 unitId;\r\n        uint96 recordId;\r\n        uint8 maxQuorum;\r\n        uint24 colCoverage;\r\n        IERC20 colAsset;\r\n        uint16 durationInHours;\r\n        address creator;\r\n        Router router; \r\n    }\r\n\r\n    struct Analytics {\r\n        uint256 tvlCollateral;\r\n        uint256 tvlBase;\r\n        uint totalPermissioned;\r\n        uint totalPermissionless;\r\n    }\r\n\r\n    struct ViewFactoryData {\r\n        Analytics analytics;\r\n        uint16 makerRate;\r\n        uint currentEpoches;\r\n        uint recordEpoches;\r\n    }\r\n\r\n    struct ContributorReturnValue {\r\n        Contributor profile;\r\n        Slot slot;\r\n        Common.Provider[] providers;\r\n    }\r\n\r\n}"
    },
    "contracts/apis/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport \"./IERC20Metadata.sol\";\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 is IERC20Metadata{\r\n    error NotCallable();\r\n    error AddressIsZero(address);\r\n    error NoPreviousLockDetected();\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    \r\n    /** \r\n     * @dev Moves `amounts` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event for each transfer.\r\n     * Note: BE AWARE OF THE GAS COST WHEN USING THIS FUNCTION. IT INCREASES \r\n                RELATIVE TO THE ACCOUNTS ARRAY\r\n     */\r\n    function batchTransfer(uint[] memory amounts, address[] memory accounts) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n\r\n    /**@dev Locks specific amount of JFT to the private ledger.\r\n        param: routeTo - Alternative address that funds will be sent to when panic call is made.\r\n        param: amount - Amount to lock.\r\n    */\r\n    function lockToken(address routeTo, uint256 amount) external returns(bool);\r\n\r\n    /**@dev Moves an 'amount' from private ledger to regular balances.\r\n        @param amount - Amount to unlock.\r\n        Note: If the lock duration was set, holder will not be able to unlock until the \r\n            set time has passed else they can withdraw to regular balance anytime.\r\n     */\r\n    function unlockToken(uint amount) external returns(bool);\r\n\r\n    /** @dev Returns seperate balances of @param who\r\n        return value will be in struct format having two values\r\n     */\r\n    function accountBalances(address who) external view returns(Balances memory);\r\n   \r\n    // /**@dev Return JFT's Metadata including the information of `who`\r\n    //  */\r\n    // function getInfo(address who) external view returns(Protected memory);\r\n\r\n    /**\r\n     * @dev PanicUnlock is meant to be invoked only by the Attorney.\r\n     * It should only be called when JFT holder has lost access to their account and they had \r\n     * earlier initiated a lock. The locked token is simply unlocked and sent to an escape address\r\n     * provided at the time the lock was activated.\r\n     * \r\n     * Note: Attorney charges a fee for doing this. \r\n     * @param account : Account that owns this token.\r\n     */\r\n    function panicUnlock(address account, Balances memory _bal) external returns(bool);\r\n\r\n    struct Protected {\r\n        uint256 value; // Total value currently locked\r\n        address escapeTo;\r\n    }\r\n\r\n    struct Balances {\r\n        uint256 spendable;\r\n        Protected locked;\r\n    }\r\n\r\n    struct TokenInfo {\r\n        uint8 decimals;\r\n        uint256 totalSupply;\r\n        string name;\r\n        string symbol;\r\n        address attorney;\r\n        // address rewarder;\r\n    }\r\n}\r\n"
    },
    "contracts/apis/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "contracts/apis/IFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"./Common.sol\";\r\n\r\ninterface IFactory is Common {\r\n  function contributeThroughProvider(Provider[] memory providers, address borrower, uint unit) external returns(bool);\r\n  function getContributorProviders(address target, uint96 recordId) external view returns(Provider[] memory);\r\n}"
    },
    "contracts/apis/IRoleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title IRoleBase \r\n * Interface of the OwnerShip contract\r\n * @author Simplifi (Bobeu)\r\n */\r\ninterface IRoleBase {\r\n    function setRole(\r\n        address[] memory newRoleTos\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function removeRole(\r\n        address target\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function renounceRole() \r\n        external\r\n        returns(bool);\r\n\r\n    function getRoleBearer(\r\n        uint ownerId\r\n    ) \r\n        external \r\n        view \r\n        returns(address);\r\n\r\n    function hasRole(\r\n        address target\r\n    )\r\n        external\r\n        view \r\n        returns(bool);\r\n}"
    },
    "contracts/apis/ISafeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title Interface of the Safe manager\r\n * @author : Simplifinance (Written by Bobeu)\r\n */\r\ninterface ISafeFactory {  \r\n  /**\r\n   * Query safe for user\r\n   * @param unit : Address to get safe for\r\n   * @return A safe if none was found, it returns address(0).\r\n   */\r\n  function getSafe(uint256 unit) external view returns(address);\r\n  // function getSafe(address user) external view returns(address);\r\n\r\n/**\r\n * Clones and return a new safe \r\n * @param unit : Target address for whom to create safe\r\n */\r\n  function pingSafe(uint256 unit) external returns(address safe);\r\n\r\n  /**\r\n   * Safe struct map\r\n   * key: user address { EOA }\r\n   * value: Safe { Contract } \r\n   */\r\n  struct SafeData {\r\n    address key;\r\n    address value;\r\n  }\r\n\r\n}"
    },
    "contracts/apis/ISupportedAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\ninterface ISupportedAsset {\r\n  function isSupportedAsset(address _asset) external view returns(bool);\r\n  function getDefaultSupportedCollateralAsset() external view returns(address _default);\r\n}"
    },
    "contracts/libraries/ErrorLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nlibrary ErrorLib {\r\n    error ErrorOccurred(string errorMsg);\r\n\r\n    /**\r\n     * @dev Reverts any operation.\r\n     * @param _error : Error struct\r\n     */\r\n    function _throw(string memory _error) internal pure {\r\n        if(bytes(_error).length > 0){ \r\n            revert ErrorOccurred(_error);\r\n        }\r\n    }\r\n\r\n}"
    },
    "contracts/peripherals/ERC20Manager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport { IERC20 } from \"../apis/IERC20.sol\";\r\nimport { ISupportedAsset } from \"../apis/ISupportedAsset.sol\";\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\nimport { SafeGetter, IRoleBase, ISafeFactory } from \"./SafeGetter.sol\";\r\n\r\nabstract contract ERC20Manager is SafeGetter {\r\n    using ErrorLib for *;\r\n\r\n    // Supportasset manager contract\r\n    ISupportedAsset public immutable assetManager;\r\n\r\n    // Base asset contract e.g cUSD\r\n    IERC20 public immutable baseAsset;\r\n\r\n    modifier onlySupportedAsset(IERC20 asset) {\r\n        if(asset != baseAsset){\r\n            if(!ISupportedAsset(assetManager).isSupportedAsset(address(asset))) 'Unsupported Asset'._throw();\r\n        }\r\n        _;\r\n    }\r\n\r\n    // ============= Constructor ================\r\n\r\n    constructor(\r\n        ISupportedAsset _assetManager, \r\n        IERC20 _baseAsset, \r\n        IRoleBase _roleManager, \r\n        ISafeFactory _safeFactory\r\n    ) SafeGetter(_safeFactory, _roleManager) {\r\n        if(_assetManager == assetManager) \"_assetManager is zero\"._throw();\r\n        if(_baseAsset == baseAsset) \"_baseAsset is zero\"._throw();\r\n        assetManager = _assetManager;\r\n        baseAsset = _baseAsset;\r\n    }\r\n\r\n    /**\r\n     * @dev Validate allowance given by user against actual value\r\n     * @param asset : ERC20 compatible contract\r\n     * @param owner : Owner account\r\n     * @param value : Value to compare allowance to\r\n     */\r\n    function _validateAllowance(\r\n        IERC20 asset, \r\n        address owner, \r\n        uint value\r\n    ) \r\n        onlySupportedAsset(asset)\r\n        internal \r\n        view\r\n        returns(uint allowance) \r\n    {\r\n        assert(address(asset) != address(0));\r\n        assert(owner != address(0));\r\n        allowance = IERC20(asset).allowance(owner, address(this));\r\n        if(allowance < value) 'Value exceed allowance'._throw();\r\n    }\r\n\r\n    /**\r\n     * @dev Validate allowance given by user against actual value\r\n     * @param asset : ERC20 compatible contract\r\n     * @param owner : Owner account\r\n     * @param beneficiary : Recipient of the allowance\r\n     * @param value : Value to compare allowance to\r\n    */\r\n    function _checkAndWithdrawAllowance(IERC20 asset, address owner, address beneficiary, uint value) internal returns(uint allowance) {\r\n        allowance = _validateAllowance(asset, owner, value);\r\n        assert(beneficiary != address(0));\r\n        assert(address(asset) != address(0));\r\n        if(allowance > 0){\r\n            if(!IERC20(asset).transferFrom(owner, beneficiary, allowance)) 'TrxFer failed'._throw();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Approve an account to spend from the contract balance\r\n     * @param asset : ERC20 compatible contract\r\n     * @param spender : Recipient of the allowance\r\n     * @param value : Amount to approve\r\n    */\r\n    function _setApprovalFor(IERC20 asset, address spender, uint value) internal {\r\n        assert(spender != address(0));\r\n        assert(address(asset) != address(0));\r\n        if(!IERC20(asset).approve(spender, value)) 'Approval Failed'._throw();\r\n    }\r\n\r\n}"
    },
    "contracts/peripherals/MinimumLiquidity.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\nimport { ERC20Manager, IRoleBase, IERC20, ISupportedAsset, ISafeFactory } from \"./ERC20Manager.sol\";\r\n\r\nabstract contract MinimumLiquidity is ERC20Manager {\r\n    using ErrorLib for *;\r\n\r\n    // Minimum liquidity a provider can make\r\n    uint public minimumLiquidity;\r\n\r\n    // ============= Constructor ================\r\n    constructor(\r\n        ISupportedAsset _assetManager,\r\n        IERC20 _baseAsset, \r\n        IRoleBase _roleManager,\r\n        ISafeFactory _safeFactory\r\n    ) ERC20Manager(_assetManager, _baseAsset, _roleManager, _safeFactory){\r\n        if(address(_roleManager) == address(0)) '_roleManager is zero'._throw();\r\n    }\r\n\r\n    /**\r\n     * @dev Set minimum liquidity. \r\n     * @param _minLiquidity : Minimum liquidity\r\n     * @notice Only accounts with rolebearer access are allowed\r\n     */\r\n    function setMinimumLiquidity(uint _minLiquidity) public onlyRoleBearer {\r\n        if(_minLiquidity == minimumLiquidity) 'Param is same'._throw();\r\n        minimumLiquidity = _minLiquidity;\r\n    }\r\n}"
    },
    "contracts/peripherals/OnlyRoleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IRoleBase } from \"../apis/IRoleBase.sol\";\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\n\r\n/**\r\n * @title MsgSender \r\n * @author Simplifi (Bobeu)\r\n * @notice Non-deployable contract simply returning the calling account.\r\n */\r\nabstract contract MsgSender {\r\n    function _msgSender() internal view virtual returns(address sender) {\r\n        sender = msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract OnlyRoleBase is MsgSender {\r\n    using ErrorLib for *;\r\n\r\n    // Role manager address\r\n    IRoleBase public roleManager;\r\n\r\n    // ============= constructor ============\r\n    constructor(IRoleBase _roleManager)\r\n    {\r\n        _setRoleManager(_roleManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Caller must have owner role before execeution can proceed.\r\n     * The 'errorMessage' argument can be used to return error specific to \r\n     * a context e.g function call. \r\n     */\r\n    modifier onlyRoleBearer {\r\n        _onlyRoleBearer();\r\n        _;\r\n    }\r\n\r\n    // Allow only account with role access\r\n    function _onlyRoleBearer() internal view {\r\n        IRoleBase mgr = roleManager;\r\n        if(address(mgr) == address(0)) 'Manager is zero'._throw();\r\n        if(!_hasRole(_msgSender())) 'Access denied'._throw();\r\n    }\r\n\r\n    function _hasRole(address target) internal view returns(bool result) {\r\n        result = IRoleBase(roleManager).hasRole(target);\r\n    }  \r\n\r\n    /// @dev Set role manager\r\n    function _setRoleManager(IRoleBase newManager) private{\r\n        roleManager = newManager;\r\n    }\r\n\r\n    /**\r\n     * Set Role manager\r\n     * @param newManager : New manager address\r\n     */\r\n    function setRoleManager(\r\n        address newManager\r\n    )\r\n        public\r\n        onlyRoleBearer\r\n        returns(bool)\r\n    {\r\n        _setRoleManager(IRoleBase(newManager));\r\n        return true;\r\n    }\r\n}"
    },
    "contracts/peripherals/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { OnlyRoleBase, IRoleBase } from \"./OnlyRoleBase.sol\";\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n * \r\n * We use part of the Openzeppelin Pausable contract to supplement our strategy.\r\n * Thanks to the OZ team.\r\n */\r\nabstract contract Pausable is OnlyRoleBase {\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is paused.\r\n     */\r\n    error EnforcedPause();\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is not paused.\r\n     */\r\n    error ExpectedPause();\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor(\r\n        IRoleBase _roleManager\r\n    ) OnlyRoleBase(_roleManager) {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view {\r\n        if (paused()) {\r\n            revert EnforcedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        if (!paused()) {\r\n            revert ExpectedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     * Only owner role can call.\r\n     * - The contract must not be paused.\r\n     */\r\n    function pause() \r\n        public \r\n        onlyRoleBearer\r\n        whenNotPaused \r\n    {\r\n        _paused = true; \r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     * - Only owner role can call.\r\n     * - The contract must be paused.\r\n     */\r\n    function unpause() \r\n        public \r\n        onlyRoleBearer \r\n        whenPaused \r\n    {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n"
    },
    "contracts/peripherals/SafeGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"../apis/Common.sol\";\r\nimport { ISafeFactory } from \"../apis/ISafeFactory.sol\";\r\nimport { Pausable, IRoleBase } from \"./Pausable.sol\";\r\n\r\n/**\r\n * @title : Safe storage contract\r\n * @author : Simplifi. Written by Isaac Jesse, a.k.a Bobeu https://github.com/bobeu\r\n * @notice : Safe is non-deployeable consumed by the FlexpoolFactory contract for managing contributors funds.\r\n *          We employed this strategy to achieve high security and users confidence while interacting with the protocol.\r\n *          The strategy utilizes the SafeGlobal protocol on the frontend to deploy a new Safe account for every unique \r\n *          contribution unit.\r\n */\r\nabstract contract SafeGetter is Pausable {\r\n\r\n    // Safe factory contract\r\n    ISafeFactory public immutable safeFactory;\r\n\r\n    // Mapping of unit contribution to Safe struct\r\n    mapping (uint256 => address) private safes;\r\n\r\n    constructor(ISafeFactory _safeFactory, IRoleBase _roleManager) Pausable(_roleManager) {\r\n        safeFactory = _safeFactory;\r\n    }\r\n\r\n    /**\r\n        * @dev Checks, validate and return safe for the target address.\r\n        * @param unit : Unit contribution.\r\n    */\r\n    function _getSafe(uint256 unit) internal returns(address safe) {\r\n        safe = ISafeFactory(safeFactory).pingSafe(unit);\r\n        assert(safe != address(0));\r\n    }\r\n}"
    },
    "contracts/standalone/celo/Providers.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport { IFactory, Common } from \"../../apis/IFactory.sol\";\r\nimport { MinimumLiquidity, IRoleBase, ErrorLib, IERC20, ISupportedAsset, ISafeFactory } from \"../../peripherals/MinimumLiquidity.sol\";\r\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\n/**\r\n * @title Providers\r\n * @author Simplifi (Bobeu)\r\n * @notice Deployable Providers contract is a general liquidity pool purposely for funding Flexpools.\r\n * Contributors that cannot afford unit contributions can access providers pool to source for funds. \r\n * Loans accessed in this pool are not withdrawable by the borrower. Since there is a direct relationship\r\n * between the Providers contract and the Flexpool's, borrowed funds are moved straight to the Flexpool contract\r\n * and registered on behalf of the contributor.\r\n * With this contract, you can perform the following actions:\r\n * - Provider liquidity.\r\n * - Remove liquidity\r\n * - Borrow to finance Flexpool\r\n * - Get the list of providers\r\n */\r\ncontract Providers is MinimumLiquidity, ReentrancyGuard {\r\n    using ErrorLib for *;\r\n    event LiquidityProvided(Common.Provider);\r\n    event LiquidityRemoved(Common.Provider);\r\n    event Borrowed(Common.Provider[] providers, address borrower);\r\n\r\n    struct Data { \r\n        uint id;\r\n        bool hasIndex;\r\n    }\r\n\r\n    // Flexpool factory contract\r\n    IFactory public immutable flexpoolFactory;\r\n\r\n    // List of providers\r\n    Common.Provider[] private providers;\r\n\r\n    /**\r\n     * @dev Mapping of providers to their position in the providers list\r\n     * @notice Slot '0' is reserved\r\n     */\r\n    mapping (address provider => Data) public slots;\r\n\r\n    /**\r\n     * ============= Constructor ================\r\n     * @param _roleManager : RoleBase manager contract.\r\n     * @param _baseAsset : Base asset to use for contribution e.g cUSD.\r\n     * @param _assetManager : Asset Manager contract.\r\n     * @notice At construction, we initialized the providers array slot 0 with an empty provider data.\r\n     * This is so we can reuse the slot in the future such as reseting a provider's data or ensuring \r\n     * that providers with zero index are restricted from calling certain functions.\r\n     */\r\n    constructor(\r\n        IFactory _flexpoolFactory,\r\n        IRoleBase _roleManager, \r\n        IERC20 _baseAsset,\r\n        ISupportedAsset _assetManager,\r\n        ISafeFactory _safeFactory\r\n    )\r\n        MinimumLiquidity(_assetManager, _baseAsset, _roleManager, _safeFactory)\r\n    {\r\n        if(address(_flexpoolFactory) == address(0)) '_flexpoolFactory is zero'._throw();\r\n        flexpoolFactory = _flexpoolFactory;\r\n    }\r\n\r\n    /**\r\n    * @dev Utility for provide liquidity\r\n    * @notice User must approve this contract with the liquidiy amount prior to this call.\r\n    * @param rate: Interest rate the provider is willing to charge.      \r\n    *   We choose a base value (numerator as 10000) repesenting a 100% of input value. This means if Alice wish to set \r\n    *   her interest rate to 0.05% for instance, she only need to multiply it by 100 i.e 0.05 * 100 = 5. Her input will be 5. \r\n    *   Since Solidity do not accept decimals as input, in our context, the minimum value to parse is '0' indicating \r\n    *   zero interest rate. If user wish to set interest at least, the minimum value will be 1 reprensenting 0.01%.\r\n    *   The minimum interest rate to set is 0.01% if interest must be set at least.\r\n    *   To reiterate, raw interest must be multiplied by 100 before giving as input. \r\n    */\r\n    function provideLiquidity(uint16 rate) public whenNotPaused returns(bool) {\r\n        if(rate >= type(uint16).max) \"Invalid rate\"._throw();\r\n        address sender = _msgSender();\r\n        Data memory data = slots[sender];\r\n        Common.Interest memory interest;\r\n        uint liquidity = _checkAndWithdrawAllowance(baseAsset, sender, address(this), minimumLiquidity);\r\n        unchecked {\r\n            if(!data.hasIndex){\r\n                data.id = providers.length;\r\n                data.hasIndex = true;\r\n                slots[sender] = data;\r\n                providers.push(Common.Provider(data.id, liquidity, rate, 0, sender, interest));\r\n            } else {\r\n                providers[data.id].amount += liquidity;\r\n            }\r\n        }\r\n\r\n        emit LiquidityProvided(providers[data.id]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove liquidity.\r\n     * @notice Liquidity can be removed anytime provided the balance exceeds zero\r\n     */\r\n    function removeLiquidity() public whenNotPaused nonReentrant returns(bool) {\r\n        (Common.Provider memory prov, uint slot, address caller) = _getProvider();\r\n        if(prov.amount == 0) \"Nothing to remove\"._throw();\r\n        providers[slot].amount = 0;\r\n        _setApprovalFor(baseAsset, caller, prov.amount);\r\n\r\n        emit LiquidityRemoved(prov);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Users can borrow from liquidity providers to finance a Flexpool\r\n     * @param providersSlots : Selected providers' slots are required \r\n     * @param amount : Amount user wish to borrow.\r\n     */\r\n    function borrow(uint[] memory providersSlots, uint amount) public whenNotPaused returns(bool) {\r\n        if(providersSlots.length == 0) 'List is empty'._throw();\r\n        if(amount == 0) 'Loan amt is 0'._throw();\r\n        Common.Provider[] memory provs = _aggregateLiquidityFromProviders(providersSlots, amount); \r\n        if(!IFactory(flexpoolFactory).contributeThroughProvider(provs, _msgSender(), amount)) 'Factory erroed'._throw();\r\n\r\n        emit Borrowed(provs, _msgSender());\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Loop through the selected providers balances, and check if there is enough balances\r\n     * to accommodate the requested loan, otherwise operation fails.\r\n     * @param providersSlots : Array of selected providers slots\r\n     * @param amount : Requested loan amount\r\n     * Return a list of providers that financed the contribution\r\n     */\r\n    function _aggregateLiquidityFromProviders(\r\n        uint[] memory providersSlots, \r\n        uint amount\r\n    ) \r\n        internal \r\n        returns(Common.Provider[] memory result)\r\n    {\r\n        uint amountLeft = amount;\r\n        uint providersSize = providersSlots.length;\r\n        Common.Provider[] memory _providers = new Common.Provider[](providersSize);\r\n        for(uint i = 0; i < providersSize; i++) {\r\n            uint slot = providersSlots[i];\r\n            if(slot >= providers.length) 'Invalid slot detected'._throw();\r\n            Common.Provider memory prov = providers[slot];\r\n            unchecked {\r\n                if(prov.amount >= amountLeft) {\r\n                    providers[slot].amount = prov.amount - amountLeft; \r\n                    amountLeft = 0;\r\n                } else {\r\n                    amountLeft -= prov.amount; \r\n                    providers[slot].amount = 0;\r\n                }\r\n            }\r\n\r\n            uint snapshotBal = providers[slot].amount;\r\n            prov.amount -= snapshotBal; // Record actual amount the provider lends to the borrower\r\n            _providers[i] = prov;\r\n            if(amountLeft == 0) break;\r\n        }\r\n        if(amountLeft > 0) 'Loan exceed aggregate providers bal'._throw();\r\n        result = _providers;\r\n    }\r\n\r\n    // ReadOnly function. Return provider's information. \r\n    function _getProvider() \r\n        internal \r\n        view \r\n        returns(Common.Provider memory prov, uint slot, address caller) \r\n    {\r\n        caller = _msgSender();\r\n        Data memory data = slots[caller];\r\n        if(!data.hasIndex) 'User is not a provider'._throw();\r\n        slot = data.id;\r\n        prov = providers[slot];\r\n    }\r\n\r\n    // Returns providers in storage.\r\n    function getProviders() public view returns(Common.Provider[] memory prov) {\r\n        prov = providers;\r\n        return prov;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "constantinople",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}