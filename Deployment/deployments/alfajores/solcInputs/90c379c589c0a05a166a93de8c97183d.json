{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/interfaces/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IERC20 } from './IERC20.sol';\r\n\r\ninterface Common {\r\n    event PoolCreated(Pool);\r\n    event NewContributorAdded(Pool);\r\n    event GetFinanced(Pool);\r\n    event Payback(Pool);\r\n    event Liquidated(Pool);\r\n    event Cancellation(uint unit);\r\n    event PoolEdited(Pool);\r\n\r\n    enum Stage {\r\n        JOIN, \r\n        GET, \r\n        PAYBACK, \r\n        CANCELED,\r\n        ENDED\r\n    }\r\n\r\n    // enum Network { HARDHAT, CELO, CROSSFI }\r\n\r\n    enum Phase { ALPHA, MAINNET }\r\n\r\n    enum Status { AVAILABLE, TAKEN }\r\n\r\n    enum Branch { CURRENT, RECORD }\r\n\r\n    enum Router { NONE, PERMISSIONLESS, PERMISSIONED }\r\n\r\n    struct Pool {\r\n        Low low;\r\n        Big big;\r\n        Addresses addrs;\r\n        Router router;\r\n        Stage stage;\r\n        Status status;\r\n    }\r\n\r\n    struct Low {\r\n        uint8 maxQuorum;\r\n        uint8 selector;\r\n        uint24 colCoverage;\r\n        uint32 duration;\r\n        uint8 allGh;\r\n        uint8 userCount;\r\n    }\r\n\r\n    struct Big {\r\n        uint256 unit;\r\n        uint256 currentPool;\r\n        uint96 recordId;\r\n        uint96 unitId;\r\n    }\r\n\r\n    struct Point {\r\n        uint contributor;\r\n        uint creator;\r\n        uint referrals;\r\n        address user;\r\n        Phase phase;\r\n    }\r\n\r\n    struct PointsReturnValue {\r\n        string key;\r\n        Point[] value;\r\n    }\r\n\r\n    struct Interest {\r\n        uint fullInterest;\r\n        uint intPerSec;\r\n    }\r\n\r\n    /**\r\n     * @notice Structured types - Address\r\n     * @param asset : Contract address of the asset in use.\r\n     * @param lastPaid: Last contributor who got finance.\r\n     * @param safe : Strategy for each pool or epoch. See Strategy.sol for more details.\r\n     * @param admin : Pool creator.\r\n     * \r\n    */\r\n    struct Addresses {\r\n        IERC20 colAsset;\r\n        address lastPaid;\r\n        address safe;\r\n        address admin;\r\n    }\r\n\r\n    /**\r\n     *  @param isMember : Whether user is a member or not\r\n     *  @param turnStartTime: Time when the contributor's turn start to count.\r\n     *  @param getFinanceTime: Date when loan was disbursed\r\n     *  @param paybackTime: Date which the borrowed fund must be retured\r\n     *  @param loan: Total debts owed by the last fund recipient.\r\n     *  @param colBals: Collateral balances of the last recipient.\r\n     *  @param sentQuota : Whether an user/current msg.sender has received or not.\r\n     *  @param id : Address of the last recipient.\r\n     * @param interestPaid : The amount of interest paid  \r\n    */\r\n    struct Contributor {\r\n        uint32 paybackTime;\r\n        uint32 turnStartTime;\r\n        uint32 getFinanceTime;\r\n        uint loan;\r\n        uint colBals;\r\n        address id;\r\n        bool sentQuota;\r\n    }\r\n\r\n    struct Price {\r\n        uint128 price;\r\n        uint8 decimals;\r\n    }\r\n\r\n    struct Provider {\r\n        uint slot;\r\n        uint amount;\r\n        uint rate;\r\n        uint earnStartDate;\r\n        address account;\r\n        Interest accruals;\r\n    }\r\n\r\n    struct Payback_Safe {\r\n        address user; \r\n        IERC20 baseAsset; \r\n        uint256 debt;\r\n        uint256 attestedInitialBal;\r\n        bool allGF; \r\n        Contributor[] cData;\r\n        bool isSwapped;\r\n        address defaulted;\r\n        uint96 recordId;\r\n        IERC20 collateralAsset;\r\n    }\r\n\r\n    struct Slot {\r\n        uint value;\r\n        bool isMember;\r\n        bool isAdmin;\r\n    }\r\n\r\n    struct ReadPoolDataReturnValue {\r\n        Pool pool;\r\n        ContributorReturnValue[] cData;\r\n    }\r\n\r\n    struct ReadRecordDataReturnValue {\r\n        Pool pool;\r\n        Contributor[] cData;\r\n    }\r\n\r\n    struct UpdatePoolData {\r\n        uint unit;\r\n        uint96 unitId;\r\n        uint96 recordId;\r\n        uint8 maxQuorum;\r\n        uint24 colCoverage;\r\n        IERC20 colAsset;\r\n        uint16 durationInHours;\r\n        address creator;\r\n        Router router; \r\n    }\r\n\r\n    struct Analytics {\r\n        uint256 tvlCollateral;\r\n        uint256 tvlBase;\r\n        uint totalPermissioned;\r\n        uint totalPermissionless;\r\n    }\r\n\r\n    struct ViewFactoryData {\r\n        Analytics analytics;\r\n        uint16 makerRate;\r\n        uint currentEpoches;\r\n        uint recordEpoches;\r\n    }\r\n\r\n    struct ContributorReturnValue {\r\n        Contributor profile;\r\n        Slot slot;\r\n        Common.Provider[] providers;\r\n    }\r\n\r\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport \"./IERC20Metadata.sol\";\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 is IERC20Metadata{\r\n    error NotCallable();\r\n    error AddressIsZero(address);\r\n    error NoPreviousLockDetected();\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    \r\n    /** \r\n     * @dev Moves `amounts` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event for each transfer.\r\n     * Note: BE AWARE OF THE GAS COST WHEN USING THIS FUNCTION. IT INCREASES \r\n                RELATIVE TO THE ACCOUNTS ARRAY\r\n     */\r\n    function batchTransfer(uint[] memory amounts, address[] memory accounts) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n\r\n    /**@dev Locks specific amount of JFT to the private ledger.\r\n        param: routeTo - Alternative address that funds will be sent to when panic call is made.\r\n        param: amount - Amount to lock.\r\n    */\r\n    function lockToken(address routeTo, uint256 amount) external returns(bool);\r\n\r\n    /**@dev Moves an 'amount' from private ledger to regular balances.\r\n        @param amount - Amount to unlock.\r\n        Note: If the lock duration was set, holder will not be able to unlock until the \r\n            set time has passed else they can withdraw to regular balance anytime.\r\n     */\r\n    function unlockToken(uint amount) external returns(bool);\r\n\r\n    /** @dev Returns seperate balances of @param who\r\n        return value will be in struct format having two values\r\n     */\r\n    function accountBalances(address who) external view returns(Balances memory);\r\n   \r\n    // /**@dev Return JFT's Metadata including the information of `who`\r\n    //  */\r\n    // function getInfo(address who) external view returns(Protected memory);\r\n\r\n    /**\r\n     * @dev PanicUnlock is meant to be invoked only by the Attorney.\r\n     * It should only be called when JFT holder has lost access to their account and they had \r\n     * earlier initiated a lock. The locked token is simply unlocked and sent to an escape address\r\n     * provided at the time the lock was activated.\r\n     * \r\n     * Note: Attorney charges a fee for doing this. \r\n     * @param account : Account that owns this token.\r\n     */\r\n    function panicUnlock(address account, Balances memory _bal) external returns(bool);\r\n\r\n    struct Protected {\r\n        uint256 value; // Total value currently locked\r\n        address escapeTo;\r\n    }\r\n\r\n    struct Balances {\r\n        uint256 spendable;\r\n        Protected locked;\r\n    }\r\n\r\n    struct TokenInfo {\r\n        uint8 decimals;\r\n        uint256 totalSupply;\r\n        string name;\r\n        string symbol;\r\n        address attorney;\r\n        // address rewarder;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"./Common.sol\";\r\n\r\ninterface IPriceOracle {\r\n  struct PriceData {\r\n    string pair;\r\n    address oracleAddress;\r\n    uint128 latestPrice;\r\n    uint128 timestampOflatestPrice;\r\n  }\r\n\r\n  // Only rolebearer function\r\n  function getPriceQuote(address asset) external view returns(uint128 price, bool inTime);\r\n  function updatePriceFeed(address asset) external;\r\n}"
    },
    "contracts/interfaces/IRoleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\n/**\r\n * @title IRoleBase \r\n * Interface of the OwnerShip contract\r\n * @author Simplifi (Bobeu)\r\n */\r\ninterface IRoleBase {\r\n    function setRole(\r\n        address[] memory newRoleTos\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function removeRole(\r\n        address target\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function renounceRole() \r\n        external\r\n        returns(bool);\r\n\r\n    function getRoleBearer(\r\n        uint ownerId\r\n    ) \r\n        external \r\n        view \r\n        returns(address);\r\n\r\n    function hasRole(\r\n        address target\r\n    )\r\n        external\r\n        view \r\n        returns(bool);\r\n}"
    },
    "contracts/interfaces/ISupportedAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { Common } from \"./Common.sol\";\r\n\r\ninterface ISupportedAsset {\r\n  struct SupportedAsset {\r\n    address id;\r\n    string name;\r\n    string symbol;\r\n  }\r\n  function isSupportedAsset(address _asset) external view returns(bool);\r\n  function getDefaultSupportedCollateralAsset() external view returns(address);\r\n} "
    },
    "contracts/libraries/ErrorLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nlibrary ErrorLib {\r\n    error ErrorOccurred(string errorMsg);\r\n\r\n    /**\r\n     * @dev Reverts any operation.\r\n     * @param _error : Error struct\r\n     */\r\n    function _throw(string memory _error) internal pure {\r\n        if(bytes(_error).length > 0){ \r\n            revert ErrorOccurred(_error);\r\n        }\r\n    }\r\n\r\n}"
    },
    "contracts/peripherals/OnlyRoleBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { IRoleBase } from \"../interfaces/IRoleBase.sol\";\r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\n\r\n/**\r\n * @title MsgSender \r\n * @author Simplifi (Bobeu)\r\n * @notice Non-deployable contract simply returning the calling account.\r\n */\r\nabstract contract MsgSender {\r\n    function _msgSender() internal view virtual returns(address sender) {\r\n        sender = msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract OnlyRoleBase is MsgSender {\r\n    using ErrorLib for *;\r\n\r\n    // Role manager address\r\n    IRoleBase public roleManager;\r\n\r\n    // ============= constructor ============\r\n    constructor(IRoleBase _roleManager)\r\n    {\r\n        _setRoleManager(_roleManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Caller must have owner role before execeution can proceed.\r\n     * The 'errorMessage' argument can be used to return error specific to \r\n     * a context e.g function call. \r\n     */\r\n    modifier onlyRoleBearer {\r\n        _onlyRoleBearer();\r\n        _;\r\n    }\r\n\r\n    // Allow only account with role access\r\n    function _onlyRoleBearer() internal view {\r\n        IRoleBase mgr = roleManager;\r\n        if(address(mgr) == address(0)) 'Manager is zero'._throw();\r\n        if(!_hasRole(_msgSender())) 'Access denied'._throw();\r\n    }\r\n\r\n    function _hasRole(address target) internal view returns(bool result) {\r\n        result = IRoleBase(roleManager).hasRole(target);\r\n    }  \r\n\r\n    /// @dev Set role manager\r\n    function _setRoleManager(IRoleBase newManager) private{\r\n        roleManager = newManager;\r\n    }\r\n\r\n    /**\r\n     * Set Role manager\r\n     * @param newManager : New manager address\r\n     */\r\n    function setRoleManager(\r\n        address newManager\r\n    )\r\n        public\r\n        onlyRoleBearer\r\n        returns(bool)\r\n    {\r\n        _setRoleManager(IRoleBase(newManager));\r\n        return true;\r\n    }\r\n}"
    },
    "contracts/peripherals/SupportedAssetManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { OnlyRoleBase, IRoleBase } from \"../peripherals/OnlyRoleBase.sol\";\r\nimport { ISupportedAsset } from \"../interfaces/ISupportedAsset.sol\"; \r\nimport { IERC20 } from \"../interfaces/IERC20.sol\"; \r\nimport { ErrorLib } from \"../libraries/ErrorLib.sol\";\r\nimport { IPriceOracle } from \"../interfaces/IPriceOracle.sol\";\r\n\r\nabstract contract SupportedAssetManager is ISupportedAsset, IPriceOracle, OnlyRoleBase {\r\n  using ErrorLib for *;\r\n\r\n  // The max acceptable amount of time passed since the oracle price was last updated.\r\n  uint128 public maxTimePassed;\r\n\r\n  // Supported assets\r\n  SupportedAsset[] private assets;\r\n\r\n  /**\r\n   * @dev Mapping assets address to bool i.e Assets must be contract account\r\n   * and must be supported\r\n   */\r\n  mapping(address => bool) private supportedAssets;\r\n\r\n  mapping(address => bool) public listed;\r\n\r\n  /**\r\n   * @dev Asset must be supported before they can be used.\r\n   */\r\n  modifier onlySupportedAsset(address _asset) {\r\n    if(!supportedAssets[_asset]) 'Unsupported asset'._throw();\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param _assets : Supported assets\r\n   * @param _roleManager : Role manager contract\r\n  */\r\n  constructor(\r\n    address[] memory _assets,\r\n    IRoleBase _roleManager\r\n  )\r\n    OnlyRoleBase(_roleManager) \r\n  {\r\n    for(uint i = 0; i < _assets.length; i++) {\r\n      if(_assets[i] != address(0)) _supportAsset(_assets[i]);\r\n    }\r\n    maxTimePassed = 60 seconds;\r\n  }\r\n\r\n  /**\r\n   * @dev Support a new asset\r\n   * Note: OnlyRoleBase action\r\n   * @param _asset : Asset to add to list of supported asset\r\n   */\r\n  function supportAsset(address _asset) \r\n    public \r\n    onlyRoleBearer\r\n  {\r\n    _supportAsset(_asset); \r\n  }\r\n\r\n  function _supportAsset(address _asset) private {\r\n    if(!listed[_asset]){\r\n      listed[_asset] = true;\r\n      assets.push(SupportedAsset(\r\n        _asset, \r\n        IERC20(_asset).name(), \r\n        IERC20(_asset).symbol()\r\n      ));\r\n    }\r\n    if(!_isAssetSupported(_asset)){\r\n      supportedAssets[_asset] = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Unsupports an asset\r\n   * Note: Only-owner action\r\n   * @param newAsset : Removes an asset from the list of supported asset\r\n   */\r\n  function unsupportAsset(\r\n    address newAsset\r\n  ) \r\n    public \r\n    onlyRoleBearer\r\n  {\r\n    supportedAssets[newAsset] = false;\r\n  }\r\n\r\n  function _isAssetSupported(address _asset) internal view returns(bool) {\r\n    return supportedAssets[_asset];\r\n  }\r\n\r\n  /**\r\n   * @dev Check if an asset is supported\r\n   */\r\n  function isSupportedAsset(address _asset) external view returns(bool) {\r\n    return _isAssetSupported(_asset);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns a list of supported assets\r\n   */\r\n  function getSupportedAssets() public view returns(SupportedAsset[] memory _assets) {\r\n    _assets = assets;\r\n    return _assets;\r\n  }\r\n\r\n  function getDefaultSupportedCollateralAsset() external view returns(address){\r\n    return assets[0].id;\r\n  }\r\n\r\n  /**\r\n   * @dev Update the maxTimePass\r\n   * @param newMaxTimePass : New maxTime\r\n   */\r\n  function setMaxTimePass(uint128 newMaxTimePass) public onlyRoleBearer returns(bool) {\r\n    maxTimePassed = newMaxTimePass;\r\n    return true;\r\n  }\r\n\r\n}"
    },
    "contracts/standalone/oracles/CeloSupportedAssetManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nimport { SupportedAssetManager, IRoleBase } from \"../../peripherals/SupportedAssetManager.sol\";\r\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\r\n\r\ncontract CeloSupportedAssetManager is SupportedAssetManager {\r\n  /**\r\n   * @notice Each asset pair on chainlink maintains a price oracle contract address\r\n   */\r\n  mapping(address => PriceData) private data;\r\n\r\n  /**\r\n   * \r\n   * @param _assets : Supported assets\r\n   * @param _roleManager : Role manager contract\r\n   * @param oracleData : Celo oracle data: optional \r\n   * @notice Ensure the length of _assets matches that of celoOracleData.\r\n  */\r\n  constructor(\r\n    address[] memory _assets,\r\n    IRoleBase _roleManager,\r\n    PriceData[] memory oracleData\r\n  )\r\n    SupportedAssetManager(_assets, _roleManager) \r\n  {\r\n    require(_assets.length == oracleData.length, \"Oracle keys & values mismatch\");\r\n    for(uint i = 0; i < _assets.length; i++) {\r\n      address asset = _assets[i];\r\n      data[asset] = oracleData[i];\r\n      // if(i == 1) {\r\n      //   // _updatePriceFeed(asset);\r\n      // }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev A function that retreives the price and the corresponding timestamp\r\n  * from the price oracle and save it in the state\r\n  * @param asset : Asset\r\n  * @param _data : Mutable oracle data.\r\n  */ \r\n  function _getPriceInfo(address asset, PriceData memory _data) internal returns(uint128 price) {\r\n    assert(asset != address(0));\r\n    (,int256 answer,,uint256 timestampOflatestPrice,) = AggregatorV3Interface(_data.oracleAddress).latestRoundData();\r\n    _data.latestPrice = uint128(uint(answer));\r\n    _data.timestampOflatestPrice = uint128(uint(timestampOflatestPrice));\r\n    data[asset] = _data;\r\n    price = _data.latestPrice;\r\n  }\r\n\r\n  /**\r\n  * @dev A function that checks if the timestamp of the saved price\r\n  * is older than maxTimePassed.\r\n  * @param timestampOflatestPrice: The time price was last updated. \r\n  * @return inTime - A bool that will be true if the price was updated\r\n  * at most maxTimePassed seconds ago, otherwise false.\r\n  */ \r\n  function _checkPriceAge(uint128 timestampOflatestPrice) internal view returns (bool inTime){\r\n    inTime = (block.timestamp - timestampOflatestPrice) < maxTimePassed;\r\n  } \r\n\r\n  /**\r\n   * @dev Get price data into external contracts\r\n   * @param asset : Asset for which to fetch price. \r\n   */\r\n  function getPriceQuote(address asset) external view returns(uint128 price, bool inTime) {\r\n    PriceData memory _data = data[asset];\r\n    (price, inTime) = (_data.latestPrice, _checkPriceAge(uint128(_data.timestampOflatestPrice)));\r\n    return (price, inTime); \r\n  }\r\n\r\n  /**\r\n   * @dev Get price data into external contracts\r\n   * @param asset : Asset for which to fetch price.\r\n   */\r\n  function _updatePriceFeed(address asset) internal returns(uint128 price) {\r\n    price = _getPriceInfo(asset, data[asset]);\r\n  }\r\n\r\n  /**\r\n   * @dev Get price data into external contracts\r\n   * @param asset : Asset for which to fetch price.\r\n   * @notice Only permitted account can update the price feed\r\n   */\r\n  function updatePriceFeed(address asset) external onlyRoleBearer {\r\n    _updatePriceFeed(asset);\r\n  }\r\n\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "constantinople",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}